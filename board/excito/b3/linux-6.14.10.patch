diff --git a/arch/arm/boot/dts/marvell/kirkwood-b3.dts b/arch/arm/boot/dts/marvell/kirkwood-b3.dts
index 681343c1357a..b148b4365f63 100644
--- a/arch/arm/boot/dts/marvell/kirkwood-b3.dts
+++ b/arch/arm/boot/dts/marvell/kirkwood-b3.dts
@@ -121,17 +121,19 @@ gpio-leds {
 		programming_led {
 			label = "bubba3:green:programming";
 			gpios = <&gpio1 6 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
+			default-state = "on";
 		};
 
 		error_led {
 			label = "bubba3:red:error";
 			gpios = <&gpio1 9 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
 		};
 
 		active_led {
 			label = "bubba3:blue:active";
 			gpios = <&gpio1 10 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
 		};
 	};
 
diff --git a/arch/arm/kernel/reboot.c b/arch/arm/kernel/reboot.c
index 3f0d5c3dae11..05398e7d4278 100644
--- a/arch/arm/kernel/reboot.c
+++ b/arch/arm/kernel/reboot.c
@@ -102,9 +102,13 @@ void machine_shutdown(void)
  */
 void machine_halt(void)
 {
+#ifdef CONFIG_KIRKWOOD_ALWAYS_RESTART
+	machine_restart(NULL);
+#else
 	local_irq_disable();
 	smp_send_stop();
 	while (1);
+#endif
 }
 
 /*
@@ -115,9 +119,13 @@ void machine_halt(void)
  */
 void machine_power_off(void)
 {
+#ifdef CONFIG_KIRKWOOD_ALWAYS_RESTART
+	machine_restart(NULL);
+#else
 	local_irq_disable();
 	smp_send_stop();
 	do_kernel_power_off();
+#endif
 }
 
 /*
diff --git a/arch/arm/mach-mvebu/Kconfig b/arch/arm/mach-mvebu/Kconfig
index 9f60a6fe0eaf..a809e0fb0ef5 100644
--- a/arch/arm/mach-mvebu/Kconfig
+++ b/arch/arm/mach-mvebu/Kconfig
@@ -128,4 +128,11 @@ config MACH_KIRKWOOD
 	  Say 'Y' here if you want your kernel to support boards based
 	  on the Marvell Kirkwood device tree.
 
+config KIRKWOOD_ALWAYS_RESTART
+	bool "Restart board when powering off kernel"
+	depends on MACH_KIRKWOOD
+	help
+	  Say 'Y' here if you want your kernel to restart
+	  when asked to power off.
+
 endif
diff --git a/drivers/net/ethernet/marvell/mv643xx_eth.c b/drivers/net/ethernet/marvell/mv643xx_eth.c
index 67a6ff07c83d..a21e4d383c4b 100644
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@ -3226,11 +3226,11 @@ static int mv643xx_eth_probe(struct platform_device *pdev)
 	dev->watchdog_timeo = 2 * HZ;
 	dev->base_addr = 0;
 
-	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO;
+	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM;
 	dev->vlan_features = dev->features;
 
 	dev->features |= NETIF_F_RXCSUM;
-	dev->hw_features = dev->features;
+	dev->hw_features = dev->features | NETIF_F_TSO;
 
 	dev->priv_flags |= IFF_UNICAST_FLT;
 	netif_set_tso_max_segs(dev, MV643XX_MAX_TSO_SEGS);
diff --git a/scripts/dtc/checks.c b/scripts/dtc/checks.c
index 6e06aeab5503..17cb6890d45a 100644
--- a/scripts/dtc/checks.c
+++ b/scripts/dtc/checks.c
@@ -31,7 +31,7 @@ typedef void (*check_fn)(struct check *c, struct dt_info *dti, struct node *node
 struct check {
 	const char *name;
 	check_fn fn;
-	const void *data;
+	void *data;
 	bool warn, error;
 	enum checkstatus status;
 	bool inprogress;
@@ -114,7 +114,6 @@ static inline void  PRINTF(5, 6) check_msg(struct check *c, struct dt_info *dti,
 	}
 
 	fputs(str, stderr);
-	free(str);
 }
 
 #define FAIL(c, dti, node, ...)						\
@@ -144,14 +143,6 @@ static void check_nodes_props(struct check *c, struct dt_info *dti, struct node
 		check_nodes_props(c, dti, child);
 }
 
-static bool is_multiple_of(int multiple, int divisor)
-{
-	if (divisor == 0)
-		return multiple == 0;
-	else
-		return (multiple % divisor) == 0;
-}
-
 static bool run_check(struct check *c, struct dt_info *dti)
 {
 	struct node *dt = dti->dt;
@@ -208,7 +199,7 @@ static void check_is_string(struct check *c, struct dt_info *dti,
 			    struct node *node)
 {
 	struct property *prop;
-	const char *propname = c->data;
+	char *propname = c->data;
 
 	prop = get_property(node, propname);
 	if (!prop)
@@ -227,7 +218,7 @@ static void check_is_string_list(struct check *c, struct dt_info *dti,
 {
 	int rem, l;
 	struct property *prop;
-	const char *propname = c->data;
+	char *propname = c->data;
 	char *str;
 
 	prop = get_property(node, propname);
@@ -255,7 +246,7 @@ static void check_is_cell(struct check *c, struct dt_info *dti,
 			  struct node *node)
 {
 	struct property *prop;
-	const char *propname = c->data;
+	char *propname = c->data;
 
 	prop = get_property(node, propname);
 	if (!prop)
@@ -306,20 +297,19 @@ ERROR(duplicate_property_names, check_duplicate_property_names, NULL);
 #define LOWERCASE	"abcdefghijklmnopqrstuvwxyz"
 #define UPPERCASE	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 #define DIGITS		"0123456789"
-#define NODECHARS	LOWERCASE UPPERCASE DIGITS ",._+-@"
-#define PROPCHARS	LOWERCASE UPPERCASE DIGITS ",._+*#?-"
+#define PROPNODECHARS	LOWERCASE UPPERCASE DIGITS ",._+*#?-"
 #define PROPNODECHARSSTRICT	LOWERCASE UPPERCASE DIGITS ",-"
 
 static void check_node_name_chars(struct check *c, struct dt_info *dti,
 				  struct node *node)
 {
-	size_t n = strspn(node->name, c->data);
+	int n = strspn(node->name, c->data);
 
 	if (n < strlen(node->name))
 		FAIL(c, dti, node, "Bad character '%c' in node name",
 		     node->name[n]);
 }
-ERROR(node_name_chars, check_node_name_chars, NODECHARS);
+ERROR(node_name_chars, check_node_name_chars, PROPNODECHARS "@");
 
 static void check_node_name_chars_strict(struct check *c, struct dt_info *dti,
 					 struct node *node)
@@ -340,20 +330,6 @@ static void check_node_name_format(struct check *c, struct dt_info *dti,
 }
 ERROR(node_name_format, check_node_name_format, NULL, &node_name_chars);
 
-static void check_node_name_vs_property_name(struct check *c,
-					     struct dt_info *dti,
-					     struct node *node)
-{
-	if (!node->parent)
-		return;
-
-	if (get_property(node->parent, node->name)) {
-		FAIL(c, dti, node, "node name and property name conflict");
-	}
-}
-WARNING(node_name_vs_property_name, check_node_name_vs_property_name,
-	NULL, &node_name_chars);
-
 static void check_unit_address_vs_reg(struct check *c, struct dt_info *dti,
 				      struct node *node)
 {
@@ -387,14 +363,14 @@ static void check_property_name_chars(struct check *c, struct dt_info *dti,
 	struct property *prop;
 
 	for_each_property(node, prop) {
-		size_t n = strspn(prop->name, c->data);
+		int n = strspn(prop->name, c->data);
 
 		if (n < strlen(prop->name))
 			FAIL_PROP(c, dti, node, prop, "Bad character '%c' in property name",
 				  prop->name[n]);
 	}
 }
-ERROR(property_name_chars, check_property_name_chars, PROPCHARS);
+ERROR(property_name_chars, check_property_name_chars, PROPNODECHARS);
 
 static void check_property_name_chars_strict(struct check *c,
 					     struct dt_info *dti,
@@ -404,7 +380,7 @@ static void check_property_name_chars_strict(struct check *c,
 
 	for_each_property(node, prop) {
 		const char *name = prop->name;
-		size_t n = strspn(name, c->data);
+		int n = strspn(name, c->data);
 
 		if (n == strlen(prop->name))
 			continue;
@@ -521,7 +497,7 @@ static cell_t check_phandle_prop(struct check *c, struct dt_info *dti,
 
 	phandle = propval_cell(prop);
 
-	if (!phandle_is_valid(phandle)) {
+	if ((phandle == 0) || (phandle == -1)) {
 		FAIL_PROP(c, dti, node, prop, "bad value (0x%x) in %s property",
 		     phandle, prop->name);
 		return 0;
@@ -580,7 +556,7 @@ static void check_name_properties(struct check *c, struct dt_info *dti,
 	if (!prop)
 		return; /* No name property, that's fine */
 
-	if ((prop->val.len != node->basenamelen + 1U)
+	if ((prop->val.len != node->basenamelen+1)
 	    || (memcmp(prop->val.val, node->name, node->basenamelen) != 0)) {
 		FAIL(c, dti, node, "\"name\" property is incorrect (\"%s\" instead"
 		     " of base node name)", prop->val.val);
@@ -681,6 +657,7 @@ ERROR(omit_unused_nodes, fixup_omit_unused_nodes, NULL, &phandle_references, &pa
  */
 WARNING_IF_NOT_CELL(address_cells_is_cell, "#address-cells");
 WARNING_IF_NOT_CELL(size_cells_is_cell, "#size-cells");
+WARNING_IF_NOT_CELL(interrupt_cells_is_cell, "#interrupt-cells");
 
 WARNING_IF_NOT_STRING(device_type_is_string, "device_type");
 WARNING_IF_NOT_STRING(model_is_string, "model");
@@ -695,7 +672,8 @@ static void check_names_is_string_list(struct check *c, struct dt_info *dti,
 	struct property *prop;
 
 	for_each_property(node, prop) {
-		if (!strends(prop->name, "-names"))
+		const char *s = strrchr(prop->name, '-');
+		if (!s || !streq(s, "-names"))
 			continue;
 
 		c->data = prop->name;
@@ -775,7 +753,7 @@ static void check_reg_format(struct check *c, struct dt_info *dti,
 	size_cells = node_size_cells(node->parent);
 	entrylen = (addr_cells + size_cells) * sizeof(cell_t);
 
-	if (!is_multiple_of(prop->val.len, entrylen))
+	if (!entrylen || (prop->val.len % entrylen) != 0)
 		FAIL_PROP(c, dti, node, prop, "property has invalid length (%d bytes) "
 			  "(#address-cells == %d, #size-cells == %d)",
 			  prop->val.len, addr_cells, size_cells);
@@ -816,7 +794,7 @@ static void check_ranges_format(struct check *c, struct dt_info *dti,
 				  "#size-cells (%d) differs from %s (%d)",
 				  ranges, c_size_cells, node->parent->fullpath,
 				  p_size_cells);
-	} else if (!is_multiple_of(prop->val.len, entrylen)) {
+	} else if ((prop->val.len % entrylen) != 0) {
 		FAIL_PROP(c, dti, node, prop, "\"%s\" property has invalid length (%d bytes) "
 			  "(parent #address-cells == %d, child #address-cells == %d, "
 			  "#size-cells == %d)", ranges, prop->val.len,
@@ -893,7 +871,7 @@ static void check_pci_device_bus_num(struct check *c, struct dt_info *dti, struc
 	} else {
 		cells = (cell_t *)prop->val.val;
 		min_bus = fdt32_to_cpu(cells[0]);
-		max_bus = fdt32_to_cpu(cells[1]);
+		max_bus = fdt32_to_cpu(cells[0]);
 	}
 	if ((bus_num < min_bus) || (bus_num > max_bus))
 		FAIL_PROP(c, dti, node, prop, "PCI bus number %d out of range, expected (%d - %d)",
@@ -1079,11 +1057,10 @@ static void check_i2c_bus_reg(struct check *c, struct dt_info *dti, struct node
 		/* Ignore I2C_OWN_SLAVE_ADDRESS */
 		reg &= ~I2C_OWN_SLAVE_ADDRESS;
 
-		if (reg & I2C_TEN_BIT_ADDRESS) {
-			if ((reg & ~I2C_TEN_BIT_ADDRESS) > 0x3ff)
-				FAIL_PROP(c, dti, node, prop, "I2C address must be less than 10-bits, got \"0x%x\"",
+		if ((reg & I2C_TEN_BIT_ADDRESS) && ((reg & ~I2C_TEN_BIT_ADDRESS) > 0x3ff))
+			FAIL_PROP(c, dti, node, prop, "I2C address must be less than 10-bits, got \"0x%x\"",
 				  reg);
-		} else if (reg > 0x7f)
+		else if (reg > 0x7f)
 			FAIL_PROP(c, dti, node, prop, "I2C address must be less than 7-bits, got \"0x%x\". Set I2C_TEN_BIT_ADDRESS for 10 bit addresses or fix the property",
 				  reg);
 	}
@@ -1110,7 +1087,7 @@ static void check_spi_bus_bridge(struct check *c, struct dt_info *dti, struct no
 		for_each_child(node, child) {
 			struct property *prop;
 			for_each_property(child, prop) {
-				if (strstarts(prop->name, "spi-")) {
+				if (strprefixeq(prop->name, 4, "spi-")) {
 					node->bus = &spi_bus;
 					break;
 				}
@@ -1182,7 +1159,7 @@ static void check_unit_address_format(struct check *c, struct dt_info *dti,
 		/* skip over 0x for next test */
 		unitname += 2;
 	}
-	if (unitname[0] == '0' && isxdigit((unsigned char)unitname[1]))
+	if (unitname[0] == '0' && isxdigit(unitname[1]))
 		FAIL(c, dti, node, "unit name should not have leading 0s");
 }
 WARNING(unit_address_format, check_unit_address_format, NULL,
@@ -1224,7 +1201,7 @@ static void check_avoid_unnecessary_addr_size(struct check *c, struct dt_info *d
 	if (!node->parent || node->addr_cells < 0 || node->size_cells < 0)
 		return;
 
-	if (get_property(node, "ranges") || get_property(node, "dma-ranges") || !node->children)
+	if (get_property(node, "ranges") || !node->children)
 		return;
 
 	for_each_child(node, child) {
@@ -1234,7 +1211,7 @@ static void check_avoid_unnecessary_addr_size(struct check *c, struct dt_info *d
 	}
 
 	if (!has_reg)
-		FAIL(c, dti, node, "unnecessary #address-cells/#size-cells without \"ranges\", \"dma-ranges\" or child \"reg\" property");
+		FAIL(c, dti, node, "unnecessary #address-cells/#size-cells without \"ranges\" or child \"reg\" property");
 }
 WARNING(avoid_unnecessary_addr_size, check_avoid_unnecessary_addr_size, NULL, &avoid_default_addr_size);
 
@@ -1384,15 +1361,15 @@ struct provider {
 };
 
 static void check_property_phandle_args(struct check *c,
-					struct dt_info *dti,
-					struct node *node,
-					struct property *prop,
-					const struct provider *provider)
+					  struct dt_info *dti,
+				          struct node *node,
+				          struct property *prop,
+				          const struct provider *provider)
 {
 	struct node *root = dti->dt;
-	unsigned int cell, cellsize = 0;
+	int cell, cellsize = 0;
 
-	if (!is_multiple_of(prop->val.len, sizeof(cell_t))) {
+	if (prop->val.len % sizeof(cell_t)) {
 		FAIL_PROP(c, dti, node, prop,
 			  "property size (%d) is invalid, expected multiple of %zu",
 			  prop->val.len, sizeof(cell_t));
@@ -1402,15 +1379,14 @@ static void check_property_phandle_args(struct check *c,
 	for (cell = 0; cell < prop->val.len / sizeof(cell_t); cell += cellsize + 1) {
 		struct node *provider_node;
 		struct property *cellprop;
-		cell_t phandle;
-		unsigned int expected;
+		int phandle;
 
 		phandle = propval_cell_n(prop, cell);
 		/*
 		 * Some bindings use a cell value 0 or -1 to skip over optional
 		 * entries when each index position has a specific definition.
 		 */
-		if (!phandle_is_valid(phandle)) {
+		if (phandle == 0 || phandle == -1) {
 			/* Give up if this is an overlay with external references */
 			if (dti->dtsflags & DTSF_PLUGIN)
 				break;
@@ -1453,12 +1429,10 @@ static void check_property_phandle_args(struct check *c,
 			break;
 		}
 
-		expected = (cell + cellsize + 1) * sizeof(cell_t);
-		if ((expected <= cell) || prop->val.len < expected) {
+		if (prop->val.len < ((cell + cellsize + 1) * sizeof(cell_t))) {
 			FAIL_PROP(c, dti, node, prop,
-				  "property size (%d) too small for cell size %u",
+				  "property size (%d) too small for cell size %d",
 				  prop->val.len, cellsize);
-			break;
 		}
 	}
 }
@@ -1467,7 +1441,7 @@ static void check_provider_cells_property(struct check *c,
 					  struct dt_info *dti,
 				          struct node *node)
 {
-	const struct provider *provider = c->data;
+	struct provider *provider = c->data;
 	struct property *prop;
 
 	prop = get_property(node, provider->prop_name);
@@ -1478,8 +1452,7 @@ static void check_provider_cells_property(struct check *c,
 }
 #define WARNING_PROPERTY_PHANDLE_CELLS(nm, propname, cells_name, ...) \
 	static struct provider nm##_provider = { (propname), (cells_name), __VA_ARGS__ }; \
-	WARNING_IF_NOT_CELL(nm##_is_cell, cells_name); \
-	WARNING(nm##_property, check_provider_cells_property, &nm##_provider, &nm##_is_cell, &phandle_references);
+	WARNING(nm##_property, check_provider_cells_property, &nm##_provider, &phandle_references);
 
 WARNING_PROPERTY_PHANDLE_CELLS(clocks, "clocks", "#clock-cells");
 WARNING_PROPERTY_PHANDLE_CELLS(cooling_device, "cooling-device", "#cooling-cells");
@@ -1500,17 +1473,24 @@ WARNING_PROPERTY_PHANDLE_CELLS(thermal_sensors, "thermal-sensors", "#thermal-sen
 
 static bool prop_is_gpio(struct property *prop)
 {
+	char *str;
+
 	/*
 	 * *-gpios and *-gpio can appear in property names,
 	 * so skip over any false matches (only one known ATM)
 	 */
-	if (strends(prop->name, ",nr-gpios"))
+	if (strstr(prop->name, "nr-gpio"))
 		return false;
 
-	return strends(prop->name, "-gpios") ||
-		streq(prop->name, "gpios") ||
-		strends(prop->name, "-gpio") ||
-		streq(prop->name, "gpio");
+	str = strrchr(prop->name, '-');
+	if (str)
+		str++;
+	else
+		str = prop->name;
+	if (!(streq(str, "gpios") || streq(str, "gpio")))
+		return false;
+
+	return true;
 }
 
 static void check_gpios_property(struct check *c,
@@ -1545,10 +1525,13 @@ static void check_deprecated_gpio_property(struct check *c,
 	struct property *prop;
 
 	for_each_property(node, prop) {
+		char *str;
+
 		if (!prop_is_gpio(prop))
 			continue;
 
-		if (!strends(prop->name, "gpio"))
+		str = strstr(prop->name, "gpio");
+		if (!streq(str, "gpio"))
 			continue;
 
 		FAIL_PROP(c, dti, node, prop,
@@ -1578,110 +1561,21 @@ static void check_interrupt_provider(struct check *c,
 				     struct node *node)
 {
 	struct property *prop;
-	bool irq_provider = node_is_interrupt_provider(node);
 
-	prop = get_property(node, "#interrupt-cells");
-	if (irq_provider && !prop) {
-		FAIL(c, dti, node,
-		     "Missing '#interrupt-cells' in interrupt provider");
+	if (!node_is_interrupt_provider(node))
 		return;
-	}
 
-	if (!irq_provider && prop) {
+	prop = get_property(node, "#interrupt-cells");
+	if (!prop)
 		FAIL(c, dti, node,
-		     "'#interrupt-cells' found, but node is not an interrupt provider");
-		return;
-	}
-}
-WARNING(interrupt_provider, check_interrupt_provider, NULL, &interrupts_extended_is_cell);
-
-static void check_interrupt_map(struct check *c,
-				struct dt_info *dti,
-				struct node *node)
-{
-	struct node *root = dti->dt;
-	struct property *prop, *irq_map_prop;
-	size_t cellsize, cell, map_cells;
+		     "Missing #interrupt-cells in interrupt provider");
 
-	irq_map_prop = get_property(node, "interrupt-map");
-	if (!irq_map_prop)
-		return;
-
-	if (node->addr_cells < 0) {
+	prop = get_property(node, "#address-cells");
+	if (!prop)
 		FAIL(c, dti, node,
-		     "Missing '#address-cells' in interrupt-map provider");
-		return;
-	}
-	cellsize = node_addr_cells(node);
-	cellsize += propval_cell(get_property(node, "#interrupt-cells"));
-
-	prop = get_property(node, "interrupt-map-mask");
-	if (prop && (prop->val.len != (cellsize * sizeof(cell_t))))
-		FAIL_PROP(c, dti, node, prop,
-			  "property size (%d) is invalid, expected %zu",
-			  prop->val.len, cellsize * sizeof(cell_t));
-
-	if (!is_multiple_of(irq_map_prop->val.len, sizeof(cell_t))) {
-		FAIL_PROP(c, dti, node, irq_map_prop,
-			  "property size (%d) is invalid, expected multiple of %zu",
-			  irq_map_prop->val.len, sizeof(cell_t));
-		return;
-	}
-
-	map_cells = irq_map_prop->val.len / sizeof(cell_t);
-	for (cell = 0; cell < map_cells; ) {
-		struct node *provider_node;
-		struct property *cellprop;
-		int phandle;
-		size_t parent_cellsize;
-
-		if ((cell + cellsize) >= map_cells) {
-			FAIL_PROP(c, dti, node, irq_map_prop,
-				  "property size (%d) too small, expected > %zu",
-				  irq_map_prop->val.len, (cell + cellsize) * sizeof(cell_t));
-			break;
-		}
-		cell += cellsize;
-
-		phandle = propval_cell_n(irq_map_prop, cell);
-		if (!phandle_is_valid(phandle)) {
-			/* Give up if this is an overlay with external references */
-			if (!(dti->dtsflags & DTSF_PLUGIN))
-				FAIL_PROP(c, dti, node, irq_map_prop,
-					  "Cell %zu is not a phandle(%d)",
-					  cell, phandle);
-			break;
-		}
-
-		provider_node = get_node_by_phandle(root, phandle);
-		if (!provider_node) {
-			FAIL_PROP(c, dti, node, irq_map_prop,
-				  "Could not get phandle(%d) node for (cell %zu)",
-				  phandle, cell);
-			break;
-		}
-
-		cellprop = get_property(provider_node, "#interrupt-cells");
-		if (cellprop) {
-			parent_cellsize = propval_cell(cellprop);
-		} else {
-			FAIL(c, dti, node, "Missing property '#interrupt-cells' in node %s or bad phandle (referred from interrupt-map[%zu])",
-			     provider_node->fullpath, cell);
-			break;
-		}
-
-		cellprop = get_property(provider_node, "#address-cells");
-		if (cellprop)
-			parent_cellsize += propval_cell(cellprop);
-
-		cell += 1 + parent_cellsize;
-		if (cell > map_cells)
-			FAIL_PROP(c, dti, node, irq_map_prop,
-				"property size (%d) mismatch, expected %zu",
-				irq_map_prop->val.len, cell * sizeof(cell_t));
-	}
+		     "Missing #address-cells in interrupt provider");
 }
-WARNING(interrupt_map, check_interrupt_map, NULL, &phandle_references, &addr_size_cells, &interrupt_provider);
+WARNING(interrupt_provider, check_interrupt_provider, NULL);
 
 static void check_interrupts_property(struct check *c,
 				      struct dt_info *dti,
@@ -1690,13 +1584,13 @@ static void check_interrupts_property(struct check *c,
 	struct node *root = dti->dt;
 	struct node *irq_node = NULL, *parent = node;
 	struct property *irq_prop, *prop = NULL;
-	cell_t irq_cells, phandle;
+	int irq_cells, phandle;
 
 	irq_prop = get_property(node, "interrupts");
 	if (!irq_prop)
 		return;
 
-	if (!is_multiple_of(irq_prop->val.len, sizeof(cell_t)))
+	if (irq_prop->val.len % sizeof(cell_t))
 		FAIL_PROP(c, dti, node, irq_prop, "size (%d) is invalid, expected multiple of %zu",
 		     irq_prop->val.len, sizeof(cell_t));
 
@@ -1709,7 +1603,7 @@ static void check_interrupts_property(struct check *c,
 		prop = get_property(parent, "interrupt-parent");
 		if (prop) {
 			phandle = propval_cell(prop);
-			if (!phandle_is_valid(phandle)) {
+			if ((phandle == 0) || (phandle == -1)) {
 				/* Give up if this is an overlay with
 				 * external references */
 				if (dti->dtsflags & DTSF_PLUGIN)
@@ -1745,7 +1639,7 @@ static void check_interrupts_property(struct check *c,
 	}
 
 	irq_cells = propval_cell(prop);
-	if (!is_multiple_of(irq_prop->val.len, irq_cells * sizeof(cell_t))) {
+	if (irq_prop->val.len % (irq_cells * sizeof(cell_t))) {
 		FAIL_PROP(c, dti, node, prop,
 			  "size is (%d), expected multiple of %d",
 			  irq_prop->val.len, (int)(irq_cells * sizeof(cell_t)));
@@ -1771,11 +1665,6 @@ static void check_graph_nodes(struct check *c, struct dt_info *dti,
 		      get_property(child, "remote-endpoint")))
 			continue;
 
-                /* The root node cannot be a port */
-		if (!node->parent) {
-			FAIL(c, dti, node, "root node contains endpoint node '%s', potentially misplaced remote-endpoint property", child->name);
-			continue;
-		}
 		node->bus = &graph_port_bus;
 
 		/* The parent of 'port' nodes can be either 'ports' or a device */
@@ -1789,6 +1678,31 @@ static void check_graph_nodes(struct check *c, struct dt_info *dti,
 }
 WARNING(graph_nodes, check_graph_nodes, NULL);
 
+static void check_graph_child_address(struct check *c, struct dt_info *dti,
+				      struct node *node)
+{
+	int cnt = 0;
+	struct node *child;
+
+	if (node->bus != &graph_ports_bus && node->bus != &graph_port_bus)
+		return;
+
+	for_each_child(node, child) {
+		struct property *prop = get_property(child, "reg");
+
+		/* No error if we have any non-zero unit address */
+		if (prop && propval_cell(prop) != 0)
+			return;
+
+		cnt++;
+	}
+
+	if (cnt == 1 && node->addr_cells != -1)
+		FAIL(c, dti, node, "graph node has single child node '%s', #address-cells/#size-cells are not necessary",
+		     node->children->name);
+}
+WARNING(graph_child_address, check_graph_child_address, NULL, &graph_nodes);
+
 static void check_graph_reg(struct check *c, struct dt_info *dti,
 			    struct node *node)
 {
@@ -1826,21 +1740,17 @@ static void check_graph_port(struct check *c, struct dt_info *dti,
 	if (node->bus != &graph_port_bus)
 		return;
 
-	check_graph_reg(c, dti, node);
-
-	/* skip checks below for overlays */
-	if (dti->dtsflags & DTSF_PLUGIN)
-		return;
-
 	if (!strprefixeq(node->name, node->basenamelen, "port"))
 		FAIL(c, dti, node, "graph port node name should be 'port'");
+
+	check_graph_reg(c, dti, node);
 }
 WARNING(graph_port, check_graph_port, NULL, &graph_nodes);
 
 static struct node *get_remote_endpoint(struct check *c, struct dt_info *dti,
 					struct node *endpoint)
 {
-	cell_t phandle;
+	int phandle;
 	struct node *node;
 	struct property *prop;
 
@@ -1850,7 +1760,7 @@ static struct node *get_remote_endpoint(struct check *c, struct dt_info *dti,
 
 	phandle = propval_cell(prop);
 	/* Give up if this is an overlay with external references */
-	if (!phandle_is_valid(phandle))
+	if (phandle == 0 || phandle == -1)
 		return NULL;
 
 	node = get_node_by_phandle(dti->dt, phandle);
@@ -1868,15 +1778,11 @@ static void check_graph_endpoint(struct check *c, struct dt_info *dti,
 	if (!node->parent || node->parent->bus != &graph_port_bus)
 		return;
 
-	check_graph_reg(c, dti, node);
-
-	/* skip checks below for overlays */
-	if (dti->dtsflags & DTSF_PLUGIN)
-		return;
-
 	if (!strprefixeq(node->name, node->basenamelen, "endpoint"))
 		FAIL(c, dti, node, "graph endpoint node name should be 'endpoint'");
 
+	check_graph_reg(c, dti, node);
+
 	remote_node = get_remote_endpoint(c, dti, node);
 	if (!remote_node)
 		return;
@@ -1887,35 +1793,10 @@ static void check_graph_endpoint(struct check *c, struct dt_info *dti,
 }
 WARNING(graph_endpoint, check_graph_endpoint, NULL, &graph_nodes);
 
-static void check_graph_child_address(struct check *c, struct dt_info *dti,
-				      struct node *node)
-{
-	int cnt = 0;
-	struct node *child;
-
-	if (node->bus != &graph_ports_bus && node->bus != &graph_port_bus)
-		return;
-
-	for_each_child(node, child) {
-		struct property *prop = get_property(child, "reg");
-
-		/* No error if we have any non-zero unit address */
-                if (prop && propval_cell(prop) != 0 )
-			return;
-
-		cnt++;
-	}
-
-	if (cnt == 1 && node->addr_cells != -1)
-		FAIL(c, dti, node, "graph node has single child node '%s', #address-cells/#size-cells are not necessary",
-		     node->children->name);
-}
-WARNING(graph_child_address, check_graph_child_address, NULL, &graph_nodes, &graph_port, &graph_endpoint);
-
 static struct check *check_table[] = {
 	&duplicate_node_names, &duplicate_property_names,
 	&node_name_chars, &node_name_format, &property_name_chars,
-	&name_is_string, &name_properties, &node_name_vs_property_name,
+	&name_is_string, &name_properties,
 
 	&duplicate_label,
 
@@ -1923,7 +1804,7 @@ static struct check *check_table[] = {
 	&phandle_references, &path_references,
 	&omit_unused_nodes,
 
-	&address_cells_is_cell, &size_cells_is_cell,
+	&address_cells_is_cell, &size_cells_is_cell, &interrupt_cells_is_cell,
 	&device_type_is_string, &model_is_string, &status_is_string,
 	&label_is_string,
 
@@ -1958,43 +1839,26 @@ static struct check *check_table[] = {
 	&chosen_node_is_root, &chosen_node_bootargs, &chosen_node_stdout_path,
 
 	&clocks_property,
-	&clocks_is_cell,
 	&cooling_device_property,
-	&cooling_device_is_cell,
 	&dmas_property,
-	&dmas_is_cell,
 	&hwlocks_property,
-	&hwlocks_is_cell,
 	&interrupts_extended_property,
-	&interrupts_extended_is_cell,
 	&io_channels_property,
-	&io_channels_is_cell,
 	&iommus_property,
-	&iommus_is_cell,
 	&mboxes_property,
-	&mboxes_is_cell,
 	&msi_parent_property,
-	&msi_parent_is_cell,
 	&mux_controls_property,
-	&mux_controls_is_cell,
 	&phys_property,
-	&phys_is_cell,
 	&power_domains_property,
-	&power_domains_is_cell,
 	&pwms_property,
-	&pwms_is_cell,
 	&resets_property,
-	&resets_is_cell,
 	&sound_dai_property,
-	&sound_dai_is_cell,
 	&thermal_sensors_property,
-	&thermal_sensors_is_cell,
 
 	&deprecated_gpio_property,
 	&gpios_property,
 	&interrupts_property,
 	&interrupt_provider,
-	&interrupt_map,
 
 	&alias_paths,
 
@@ -2018,7 +1882,7 @@ static void enable_warning_error(struct check *c, bool warn, bool error)
 
 static void disable_warning_error(struct check *c, bool warn, bool error)
 {
-	unsigned int i;
+	int i;
 
 	/* Lowering level, also lower it for things this is the prereq
 	 * for */
@@ -2039,7 +1903,7 @@ static void disable_warning_error(struct check *c, bool warn, bool error)
 
 void parse_checks_option(bool warn, bool error, const char *arg)
 {
-	unsigned int i;
+	int i;
 	const char *name = arg;
 	bool enable = true;
 
@@ -2066,7 +1930,7 @@ void parse_checks_option(bool warn, bool error, const char *arg)
 
 void process_checks(bool force, struct dt_info *dti)
 {
-	unsigned int i;
+	int i;
 	int error = 0;
 
 	for (i = 0; i < ARRAY_SIZE(check_table); i++) {
diff --git a/scripts/dtc/data.c b/scripts/dtc/data.c
index 14734233ad8b..0a43b6de3264 100644
--- a/scripts/dtc/data.c
+++ b/scripts/dtc/data.c
@@ -21,10 +21,10 @@ void data_free(struct data d)
 		free(d.val);
 }
 
-struct data data_grow_for(struct data d, unsigned int xlen)
+struct data data_grow_for(struct data d, int xlen)
 {
 	struct data nd;
-	unsigned int newsize;
+	int newsize;
 
 	if (xlen == 0)
 		return d;
@@ -84,7 +84,7 @@ struct data data_copy_file(FILE *f, size_t maxlen)
 	while (!feof(f) && (d.len < maxlen)) {
 		size_t chunksize, ret;
 
-		if (maxlen == (size_t)-1)
+		if (maxlen == -1)
 			chunksize = 4096;
 		else
 			chunksize = maxlen - d.len;
diff --git a/scripts/dtc/dtc-lexer.l b/scripts/dtc/dtc-lexer.l
index de60a70b6bdb..b3b7270300de 100644
--- a/scripts/dtc/dtc-lexer.l
+++ b/scripts/dtc/dtc-lexer.l
@@ -57,7 +57,7 @@ static void PRINTF(1, 2) lexical_error(const char *fmt, ...);
 			push_input_file(name);
 		}
 
-<*>^"#"(line)?[ \t]+[0-9]+[ \t]+{STRING}([ \t]+[0-9]+)* {
+<*>^"#"(line)?[ \t]+[0-9]+[ \t]+{STRING}([ \t]+[0-9]+)? {
 			char *line, *fnstart, *fnend;
 			struct data fn;
 			/* skip text before line # */
@@ -200,7 +200,7 @@ static void PRINTF(1, 2) lexical_error(const char *fmt, ...);
 			return DT_LABEL_REF;
 		}
 
-<*>"&{"{PATHCHAR}*\}	{	/* new-style path reference */
+<*>"&{/"{PATHCHAR}*\}	{	/* new-style path reference */
 			yytext[yyleng-1] = '\0';
 			DPRINT("Ref: %s\n", yytext+2);
 			yylval.labelref = xstrdup(yytext+2);
diff --git a/scripts/dtc/dtc-parser.y b/scripts/dtc/dtc-parser.y
index 4d5eece52624..a0316a3cc309 100644
--- a/scripts/dtc/dtc-parser.y
+++ b/scripts/dtc/dtc-parser.y
@@ -23,12 +23,6 @@ extern void yyerror(char const *s);
 
 extern struct dt_info *parser_output;
 extern bool treesource_error;
-
-static bool is_ref_relative(const char *ref)
-{
-	return ref[0] != '/' && strchr(&ref[1], '/');
-}
-
 %}
 
 %union {
@@ -175,8 +169,6 @@ devicetree:
 			 */
 			if (!($<flags>-1 & DTSF_PLUGIN))
 				ERROR(&@2, "Label or path %s not found", $1);
-			else if (is_ref_relative($1))
-				ERROR(&@2, "Label-relative reference %s not supported in plugin", $1);
 			$$ = add_orphan_node(
 					name_node(build_node(NULL, NULL, NULL),
 						  ""),
@@ -186,9 +178,6 @@ devicetree:
 		{
 			struct node *target = get_node_by_ref($1, $3);
 
-			if (($<flags>-1 & DTSF_PLUGIN) && is_ref_relative($3))
-				ERROR(&@2, "Label-relative reference %s not supported in plugin", $3);
-
 			if (target) {
 				add_label(&target->labels, $2);
 				merge_nodes(target, $4);
@@ -204,8 +193,6 @@ devicetree:
 			 * so $-1 is what we want (plugindecl)
 			 */
 			if ($<flags>-1 & DTSF_PLUGIN) {
-				if (is_ref_relative($2))
-					ERROR(&@2, "Label-relative reference %s not supported in plugin", $2);
 				add_orphan_node($1, $3, $2);
 			} else {
 				struct node *target = get_node_by_ref($1, $2);
@@ -284,17 +271,14 @@ propdef:
 	  DT_PROPNODENAME '=' propdata ';'
 		{
 			$$ = build_property($1, $3, &@$);
-			free($1);
 		}
 	| DT_PROPNODENAME ';'
 		{
 			$$ = build_property($1, empty_data, &@$);
-			free($1);
 		}
 	| DT_DEL_PROP DT_PROPNODENAME ';'
 		{
 			$$ = build_property_delete($2);
-			free($2);
 		}
 	| DT_LABEL propdef
 		{
@@ -407,14 +391,9 @@ arrayprefix:
 				 * within the mask to one (i.e. | in the
 				 * mask), all bits are one.
 				 */
-				if (($2 > mask) && (($2 | mask) != -1ULL)) {
-					char *loc = srcpos_string(&@2);
-					fprintf(stderr,
-						"WARNING: %s: Value 0x%016" PRIx64
-						" truncated to 0x%0*" PRIx64 "\n",
-						loc, $2, $1.bits / 4, ($2 & mask));
-					free(loc);
-				}
+				if (($2 > mask) && (($2 | mask) != -1ULL))
+					ERROR(&@2, "Value out of range for"
+					      " %d-bit array element", $1.bits);
 			}
 
 			$$.data = data_append_integer($1.data, $2, $1.bits);
@@ -573,12 +552,10 @@ subnode:
 	  DT_PROPNODENAME nodedef
 		{
 			$$ = name_node($2, $1);
-			free($1);
 		}
 	| DT_DEL_NODE DT_PROPNODENAME ';'
 		{
 			$$ = name_node(build_node_delete(&@$), $2);
-			free($2);
 		}
 	| DT_OMIT_NO_REF subnode
 		{
diff --git a/scripts/dtc/dtc.c b/scripts/dtc/dtc.c
index 0655c2e2c362..bdb3f5945699 100644
--- a/scripts/dtc/dtc.c
+++ b/scripts/dtc/dtc.c
@@ -12,7 +12,7 @@
  * Command line options
  */
 int quiet;		/* Level of quietness */
-unsigned int reservenum;/* Number of memory reservation slots */
+int reservenum;		/* Number of memory reservation slots */
 int minsize;		/* Minimum blob size */
 int padsize;		/* Additional padding to blob */
 int alignsize;		/* Additional padding to blob accroding to the alignsize */
@@ -47,7 +47,7 @@ static void fill_fullpaths(struct node *tree, const char *prefix)
 
 /* Usage related data. */
 static const char usage_synopsis[] = "dtc [options] <input file>";
-static const char usage_short_opts[] = "qI:O:o:V:d:R:S:p:a:fb:i:H:sW:E:@LAThv";
+static const char usage_short_opts[] = "qI:O:o:V:d:R:S:p:a:fb:i:H:sW:E:@AThv";
 static struct option const usage_long_opts[] = {
 	{"quiet",            no_argument, NULL, 'q'},
 	{"in-format",         a_argument, NULL, 'I'},
@@ -67,7 +67,6 @@ static struct option const usage_long_opts[] = {
 	{"warning",           a_argument, NULL, 'W'},
 	{"error",             a_argument, NULL, 'E'},
 	{"symbols",	     no_argument, NULL, '@'},
-	{"local-fixups",     no_argument, NULL, 'L'},
 	{"auto-alias",       no_argument, NULL, 'A'},
 	{"annotate",         no_argument, NULL, 'T'},
 	{"help",             no_argument, NULL, 'h'},
@@ -105,7 +104,6 @@ static const char * const usage_opts_help[] = {
 	"\n\tEnable/disable warnings (prefix with \"no-\")",
 	"\n\tEnable/disable errors (prefix with \"no-\")",
 	"\n\tEnable generation of symbols",
-	"\n\tPossibly generates a __local_fixups__ and a __fixups__ node at the root node",
 	"\n\tEnable auto-alias of labels",
 	"\n\tAnnotate output .dts with input source file and line (-T -T for more details)",
 	"\n\tPrint this help and exit",
@@ -124,8 +122,6 @@ static const char *guess_type_by_name(const char *fname, const char *fallback)
 		return "dts";
 	if (!strcasecmp(s, ".yaml"))
 		return "yaml";
-	if (!strcasecmp(s, ".dtbo"))
-		return "dtb";
 	if (!strcasecmp(s, ".dtb"))
 		return "dtb";
 	return fallback;
@@ -199,7 +195,7 @@ int main(int argc, char *argv[])
 			depname = optarg;
 			break;
 		case 'R':
-			reservenum = strtoul(optarg, NULL, 0);
+			reservenum = strtol(optarg, NULL, 0);
 			break;
 		case 'S':
 			minsize = strtol(optarg, NULL, 0);
@@ -254,11 +250,6 @@ int main(int argc, char *argv[])
 		case '@':
 			generate_symbols = 1;
 			break;
-
-		case 'L':
-			generate_fixups = 1;
-			break;
-
 		case 'A':
 			auto_label_aliases = 1;
 			break;
diff --git a/scripts/dtc/dtc.h b/scripts/dtc/dtc.h
index 4c4aaca1fc41..a08f4159cd03 100644
--- a/scripts/dtc/dtc.h
+++ b/scripts/dtc/dtc.h
@@ -35,7 +35,7 @@
  * Command line options
  */
 extern int quiet;		/* Level of quietness */
-extern unsigned int reservenum;	/* Number of memory reservation slots */
+extern int reservenum;		/* Number of memory reservation slots */
 extern int minsize;		/* Minimum blob size */
 extern int padsize;		/* Additional padding to blob */
 extern int alignsize;		/* Additional padding to blob accroding to the alignsize */
@@ -51,11 +51,6 @@ extern int annotate;		/* annotate .dts with input source location */
 
 typedef uint32_t cell_t;
 
-static inline bool phandle_is_valid(cell_t phandle)
-{
-	return phandle != 0 && phandle != ~0U;
-}
-
 static inline uint16_t dtb_ld16(const void *p)
 {
 	const uint8_t *bp = (const uint8_t *)p;
@@ -91,16 +86,6 @@ static inline uint64_t dtb_ld64(const void *p)
 #define streq(a, b)	(strcmp((a), (b)) == 0)
 #define strstarts(s, prefix)	(strncmp((s), (prefix), strlen(prefix)) == 0)
 #define strprefixeq(a, n, b)	(strlen(b) == (n) && (memcmp(a, b, n) == 0))
-static inline bool strends(const char *str, const char *suffix)
-{
-	unsigned int len, suffix_len;
-
-	len = strlen(str);
-	suffix_len = strlen(suffix);
-	if (len < suffix_len)
-		return false;
-	return streq(str + len - suffix_len, suffix);
-}
 
 #define ALIGN(x, a)	(((x) + (a) - 1) & ~((a) - 1))
 
@@ -116,23 +101,17 @@ enum markertype {
 	TYPE_UINT64,
 	TYPE_STRING,
 };
-
-static inline bool is_type_marker(enum markertype type)
-{
-	return type >= TYPE_UINT8;
-}
-
 extern const char *markername(enum markertype markertype);
 
 struct  marker {
 	enum markertype type;
-	unsigned int offset;
+	int offset;
 	char *ref;
 	struct marker *next;
 };
 
 struct data {
-	unsigned int len;
+	int len;
 	char *val;
 	struct marker *markers;
 };
@@ -146,26 +125,11 @@ struct data {
 	for_each_marker(m) \
 		if ((m)->type == (t))
 
-static inline struct marker *next_type_marker(struct marker *m)
-{
-	for_each_marker(m)
-		if (is_type_marker(m->type))
-			break;
-	return m;
-}
-
-static inline size_t type_marker_length(struct marker *m)
-{
-	struct marker *next = next_type_marker(m->next);
-
-	if (next)
-		return next->offset - m->offset;
-	return 0;
-}
+size_t type_marker_length(struct marker *m);
 
 void data_free(struct data d);
 
-struct data data_grow_for(struct data d, unsigned int xlen);
+struct data data_grow_for(struct data d, int xlen);
 
 struct data data_copy_mem(const char *mem, int len);
 struct data data_copy_escape_string(const char *s, int len);
@@ -260,16 +224,16 @@ struct node {
 void add_label(struct label **labels, char *label);
 void delete_labels(struct label **labels);
 
-struct property *build_property(const char *name, struct data val,
+struct property *build_property(char *name, struct data val,
 				struct srcpos *srcpos);
-struct property *build_property_delete(const char *name);
+struct property *build_property_delete(char *name);
 struct property *chain_property(struct property *first, struct property *list);
 struct property *reverse_properties(struct property *first);
 
 struct node *build_node(struct property *proplist, struct node *children,
 			struct srcpos *srcpos);
 struct node *build_node_delete(struct srcpos *srcpos);
-struct node *name_node(struct node *node, const char *name);
+struct node *name_node(struct node *node, char *name);
 struct node *omit_node_if_unused(struct node *node);
 struct node *reference_node(struct node *node);
 struct node *chain_node(struct node *first, struct node *list);
@@ -289,7 +253,7 @@ void append_to_property(struct node *node,
 const char *get_unitname(struct node *node);
 struct property *get_property(struct node *node, const char *propname);
 cell_t propval_cell(struct property *prop);
-cell_t propval_cell_n(struct property *prop, unsigned int n);
+cell_t propval_cell_n(struct property *prop, int n);
 struct property *get_property_by_label(struct node *tree, const char *label,
 				       struct node **node);
 struct marker *get_marker_label(struct node *tree, const char *label,
@@ -336,9 +300,9 @@ struct dt_info *build_dt_info(unsigned int dtsflags,
 			      struct reserve_info *reservelist,
 			      struct node *tree, uint32_t boot_cpuid_phys);
 void sort_tree(struct dt_info *dti);
-void generate_label_tree(struct dt_info *dti, const char *name, bool allocph);
-void generate_fixups_tree(struct dt_info *dti, const char *name);
-void generate_local_fixups_tree(struct dt_info *dti, const char *name);
+void generate_label_tree(struct dt_info *dti, char *name, bool allocph);
+void generate_fixups_tree(struct dt_info *dti, char *name);
+void generate_local_fixups_tree(struct dt_info *dti, char *name);
 
 /* Checks */
 
diff --git a/scripts/dtc/fdtoverlay.c b/scripts/dtc/fdtoverlay.c
index 699b4f616502..5350af65679f 100644
--- a/scripts/dtc/fdtoverlay.c
+++ b/scripts/dtc/fdtoverlay.c
@@ -23,7 +23,9 @@
 /* Usage related data. */
 static const char usage_synopsis[] =
 	"apply a number of overlays to a base blob\n"
-	"	fdtoverlay <options> [<overlay.dtbo> [<overlay.dtbo>]]";
+	"	fdtoverlay <options> [<overlay.dtbo> [<overlay.dtbo>]]\n"
+	"\n"
+	USAGE_TYPE_MSG;
 static const char usage_short_opts[] = "i:o:v" USAGE_COMMON_SHORT_OPTS;
 static struct option const usage_long_opts[] = {
 	{"input",            required_argument, NULL, 'i'},
@@ -48,7 +50,7 @@ static void *apply_one(char *base, const char *overlay, size_t *buf_len,
 	int ret;
 
 	/*
-	 * We take copies first, because a failed apply can trash
+	 * We take a copies first, because a a failed apply can trash
 	 * both the base blob and the overlay
 	 */
 	tmpo = xmalloc(fdt_totalsize(overlay));
diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index 1bcd8089c5b9..07f10d2b5d79 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -124,8 +124,7 @@ static void asm_emit_cell(void *e, cell_t val)
 {
 	FILE *f = e;
 
-	fprintf(f, "\t.byte\t0x%02x\n" "\t.byte\t0x%02x\n"
-		"\t.byte\t0x%02x\n" "\t.byte\t0x%02x\n",
+	fprintf(f, "\t.byte 0x%02x; .byte 0x%02x; .byte 0x%02x; .byte 0x%02x\n",
 		(val >> 24) & 0xff, (val >> 16) & 0xff,
 		(val >> 8) & 0xff, val & 0xff);
 }
@@ -135,9 +134,9 @@ static void asm_emit_string(void *e, const char *str, int len)
 	FILE *f = e;
 
 	if (len != 0)
-		fprintf(f, "\t.asciz\t\"%.*s\"\n", len, str);
+		fprintf(f, "\t.string\t\"%.*s\"\n", len, str);
 	else
-		fprintf(f, "\t.asciz\t\"%s\"\n", str);
+		fprintf(f, "\t.string\t\"%s\"\n", str);
 }
 
 static void asm_emit_align(void *e, int a)
@@ -150,7 +149,7 @@ static void asm_emit_align(void *e, int a)
 static void asm_emit_data(void *e, struct data d)
 {
 	FILE *f = e;
-	unsigned int off = 0;
+	int off = 0;
 	struct marker *m = d.markers;
 
 	for_each_marker_of_type(m, LABEL)
@@ -220,7 +219,7 @@ static struct emitter asm_emitter = {
 
 static int stringtable_insert(struct data *d, const char *str)
 {
-	unsigned int i;
+	int i;
 
 	/* FIXME: do this more efficiently? */
 
@@ -296,7 +295,7 @@ static struct data flatten_reserve_list(struct reserve_info *reservelist,
 {
 	struct reserve_info *re;
 	struct data d = empty_data;
-	unsigned int j;
+	int    j;
 
 	for (re = reservelist; re; re = re->next) {
 		d = data_append_re(d, re->address, re->size);
@@ -346,7 +345,7 @@ static void make_fdt_header(struct fdt_header *fdt,
 void dt_to_blob(FILE *f, struct dt_info *dti, int version)
 {
 	struct version_info *vi = NULL;
-	unsigned int i;
+	int i;
 	struct data blob       = empty_data;
 	struct data reservebuf = empty_data;
 	struct data dtbuf      = empty_data;
@@ -439,7 +438,7 @@ static void dump_stringtable_asm(FILE *f, struct data strbuf)
 
 	while (p < (strbuf.val + strbuf.len)) {
 		len = strlen(p);
-		fprintf(f, "\t.asciz \"%s\"\n", p);
+		fprintf(f, "\t.string \"%s\"\n", p);
 		p += len+1;
 	}
 }
@@ -447,7 +446,7 @@ static void dump_stringtable_asm(FILE *f, struct data strbuf)
 void dt_to_asm(FILE *f, struct dt_info *dti, int version)
 {
 	struct version_info *vi = NULL;
-	unsigned int i;
+	int i;
 	struct data strbuf = empty_data;
 	struct reserve_info *re;
 	const char *symprefix = "dt";
@@ -604,11 +603,11 @@ static void flat_realign(struct inbuf *inb, int align)
 		die("Premature end of data parsing flat device tree\n");
 }
 
-static const char *flat_read_string(struct inbuf *inb)
+static char *flat_read_string(struct inbuf *inb)
 {
 	int len = 0;
 	const char *p = inb->ptr;
-	const char *str;
+	char *str;
 
 	do {
 		if (p >= inb->limit)
@@ -616,7 +615,7 @@ static const char *flat_read_string(struct inbuf *inb)
 		len++;
 	} while ((*p++) != '\0');
 
-	str = inb->ptr;
+	str = xstrdup(inb->ptr);
 
 	inb->ptr += len;
 
@@ -711,7 +710,7 @@ static struct reserve_info *flat_read_mem_reserve(struct inbuf *inb)
 }
 
 
-static const char *nodename_from_path(const char *ppath, const char *cpath)
+static char *nodename_from_path(const char *ppath, const char *cpath)
 {
 	int plen;
 
@@ -725,7 +724,7 @@ static const char *nodename_from_path(const char *ppath, const char *cpath)
 	if (!streq(ppath, "/"))
 		plen++;
 
-	return cpath + plen;
+	return xstrdup(cpath + plen);
 }
 
 static struct node *unflatten_tree(struct inbuf *dtbuf,
@@ -733,7 +732,7 @@ static struct node *unflatten_tree(struct inbuf *dtbuf,
 				   const char *parent_flatname, int flags)
 {
 	struct node *node;
-	const char *flatname;
+	char *flatname;
 	uint32_t val;
 
 	node = build_node(NULL, NULL, NULL);
@@ -741,10 +740,9 @@ static struct node *unflatten_tree(struct inbuf *dtbuf,
 	flatname = flat_read_string(dtbuf);
 
 	if (flags & FTF_FULLPATH)
-		node->name = xstrdup(nodename_from_path(parent_flatname,
-							flatname));
+		node->name = nodename_from_path(parent_flatname, flatname);
 	else
-		node->name = xstrdup(flatname);
+		node->name = flatname;
 
 	do {
 		struct property *prop;
@@ -786,6 +784,10 @@ static struct node *unflatten_tree(struct inbuf *dtbuf,
 		}
 	} while (val != FDT_END_NODE);
 
+	if (node->name != flatname) {
+		free(flatname);
+	}
+
 	return node;
 }
 
diff --git a/scripts/dtc/fstree.c b/scripts/dtc/fstree.c
index 0f9a534bacdb..5e59594ab301 100644
--- a/scripts/dtc/fstree.c
+++ b/scripts/dtc/fstree.c
@@ -43,7 +43,7 @@ static struct node *read_fstree(const char *dirname)
 					"WARNING: Cannot open %s: %s\n",
 					tmpname, strerror(errno));
 			} else {
-				prop = build_property(de->d_name,
+				prop = build_property(xstrdup(de->d_name),
 						      data_copy_file(pfile,
 								     st.st_size),
 						      NULL);
diff --git a/scripts/dtc/libfdt/fdt.c b/scripts/dtc/libfdt/fdt.c
index 20c6415b9ced..6cf2fa03b037 100644
--- a/scripts/dtc/libfdt/fdt.c
+++ b/scripts/dtc/libfdt/fdt.c
@@ -22,10 +22,6 @@ int32_t fdt_ro_probe_(const void *fdt)
 	if (can_assume(VALID_DTB))
 		return totalsize;
 
-	/* The device tree must be at an 8-byte aligned address */
-	if ((uintptr_t)fdt & 7)
-		return -FDT_ERR_ALIGNMENT;
-
 	if (fdt_magic(fdt) == FDT_MAGIC) {
 		/* Complete tree */
 		if (!can_assume(LATEST)) {
@@ -90,10 +86,6 @@ int fdt_check_header(const void *fdt)
 {
 	size_t hdrsize;
 
-	/* The device tree must be at an 8-byte aligned address */
-	if ((uintptr_t)fdt & 7)
-		return -FDT_ERR_ALIGNMENT;
-
 	if (fdt_magic(fdt) != FDT_MAGIC)
 		return -FDT_ERR_BADMAGIC;
 	if (!can_assume(LATEST)) {
@@ -106,6 +98,7 @@ int fdt_check_header(const void *fdt)
 	}
 	hdrsize = fdt_header_size(fdt);
 	if (!can_assume(VALID_DTB)) {
+
 		if ((fdt_totalsize(fdt) < hdrsize)
 		    || (fdt_totalsize(fdt) > INT_MAX))
 			return -FDT_ERR_TRUNCATED;
@@ -114,7 +107,9 @@ int fdt_check_header(const void *fdt)
 		if (!check_off_(hdrsize, fdt_totalsize(fdt),
 				fdt_off_mem_rsvmap(fdt)))
 			return -FDT_ERR_TRUNCATED;
+	}
 
+	if (!can_assume(VALID_DTB)) {
 		/* Bounds check structure block */
 		if (!can_assume(LATEST) && fdt_version(fdt) < 17) {
 			if (!check_off_(hdrsize, fdt_totalsize(fdt),
@@ -162,7 +157,7 @@ const void *fdt_offset_ptr(const void *fdt, int offset, unsigned int len)
 uint32_t fdt_next_tag(const void *fdt, int startoffset, int *nextoffset)
 {
 	const fdt32_t *tagp, *lenp;
-	uint32_t tag, len, sum;
+	uint32_t tag;
 	int offset = startoffset;
 	const char *p;
 
@@ -188,19 +183,12 @@ uint32_t fdt_next_tag(const void *fdt, int startoffset, int *nextoffset)
 		lenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));
 		if (!can_assume(VALID_DTB) && !lenp)
 			return FDT_END; /* premature end */
-
-		len = fdt32_to_cpu(*lenp);
-		sum = len + offset;
-		if (!can_assume(VALID_DTB) &&
-		    (INT_MAX <= sum || sum < (uint32_t) offset))
-			return FDT_END; /* premature end */
-
 		/* skip-name offset, length and value */
-		offset += sizeof(struct fdt_property) - FDT_TAGSIZE + len;
-
+		offset += sizeof(struct fdt_property) - FDT_TAGSIZE
+			+ fdt32_to_cpu(*lenp);
 		if (!can_assume(LATEST) &&
-		    fdt_version(fdt) < 0x10 && len >= 8 &&
-		    ((offset - len) % 8) != 0)
+		    fdt_version(fdt) < 0x10 && fdt32_to_cpu(*lenp) >= 8 &&
+		    ((offset - fdt32_to_cpu(*lenp)) % 8) != 0)
 			offset += 4;
 		break;
 
diff --git a/scripts/dtc/libfdt/fdt_addresses.c b/scripts/dtc/libfdt/fdt_addresses.c
index c40ba094f1f8..9a82cd0ba2f9 100644
--- a/scripts/dtc/libfdt/fdt_addresses.c
+++ b/scripts/dtc/libfdt/fdt_addresses.c
@@ -73,7 +73,7 @@ int fdt_appendprop_addrrange(void *fdt, int parent, int nodeoffset,
 	/* check validity of address */
 	prop = data;
 	if (addr_cells == 1) {
-		if ((addr > UINT32_MAX) || (((uint64_t) UINT32_MAX + 1 - addr) < size))
+		if ((addr > UINT32_MAX) || ((UINT32_MAX + 1 - addr) < size))
 			return -FDT_ERR_BADVALUE;
 
 		fdt32_st(prop, (uint32_t)addr);
diff --git a/scripts/dtc/libfdt/fdt_overlay.c b/scripts/dtc/libfdt/fdt_overlay.c
index 28b667ffc490..d217e79b6722 100644
--- a/scripts/dtc/libfdt/fdt_overlay.c
+++ b/scripts/dtc/libfdt/fdt_overlay.c
@@ -40,22 +40,37 @@ static uint32_t overlay_get_target_phandle(const void *fdto, int fragment)
 	return fdt32_to_cpu(*val);
 }
 
-int fdt_overlay_target_offset(const void *fdt, const void *fdto,
-			      int fragment_offset, char const **pathp)
+/**
+ * overlay_get_target - retrieves the offset of a fragment's target
+ * @fdt: Base device tree blob
+ * @fdto: Device tree overlay blob
+ * @fragment: node offset of the fragment in the overlay
+ * @pathp: pointer which receives the path of the target (or NULL)
+ *
+ * overlay_get_target() retrieves the target offset in the base
+ * device tree of a fragment, no matter how the actual targeting is
+ * done (through a phandle or a path)
+ *
+ * returns:
+ *      the targeted node offset in the base device tree
+ *      Negative error code on error
+ */
+static int overlay_get_target(const void *fdt, const void *fdto,
+			      int fragment, char const **pathp)
 {
 	uint32_t phandle;
 	const char *path = NULL;
 	int path_len = 0, ret;
 
 	/* Try first to do a phandle based lookup */
-	phandle = overlay_get_target_phandle(fdto, fragment_offset);
+	phandle = overlay_get_target_phandle(fdto, fragment);
 	if (phandle == (uint32_t)-1)
 		return -FDT_ERR_BADPHANDLE;
 
 	/* no phandle, try path */
 	if (!phandle) {
 		/* And then a path based lookup */
-		path = fdt_getprop(fdto, fragment_offset, "target-path", &path_len);
+		path = fdt_getprop(fdto, fragment, "target-path", &path_len);
 		if (path)
 			ret = fdt_path_offset(fdt, path);
 		else
@@ -101,22 +116,26 @@ int fdt_overlay_target_offset(const void *fdt, const void *fdto,
 static int overlay_phandle_add_offset(void *fdt, int node,
 				      const char *name, uint32_t delta)
 {
-	fdt32_t *valp, val;
+	const fdt32_t *val;
+	uint32_t adj_val;
 	int len;
 
-	valp = fdt_getprop_w(fdt, node, name, &len);
-	if (!valp)
+	val = fdt_getprop(fdt, node, name, &len);
+	if (!val)
 		return len;
 
-	if (len != sizeof(val))
+	if (len != sizeof(*val))
 		return -FDT_ERR_BADPHANDLE;
 
-	val = fdt32_ld(valp);
-	if (val + delta < val || val + delta == (uint32_t)-1)
+	adj_val = fdt32_to_cpu(*val);
+	if ((adj_val + delta) < adj_val)
 		return -FDT_ERR_NOPHANDLES;
 
-	fdt32_st(valp, val + delta);
-	return 0;
+	adj_val += delta;
+	if (adj_val == (uint32_t)-1)
+		return -FDT_ERR_NOPHANDLES;
+
+	return fdt_setprop_inplace_u32(fdt, node, name, adj_val);
 }
 
 /**
@@ -209,8 +228,8 @@ static int overlay_update_local_node_references(void *fdto,
 
 	fdt_for_each_property_offset(fixup_prop, fdto, fixup_node) {
 		const fdt32_t *fixup_val;
+		const char *tree_val;
 		const char *name;
-		char *tree_val;
 		int fixup_len;
 		int tree_len;
 		int i;
@@ -224,7 +243,7 @@ static int overlay_update_local_node_references(void *fdto,
 			return -FDT_ERR_BADOVERLAY;
 		fixup_len /= sizeof(uint32_t);
 
-		tree_val = fdt_getprop_w(fdto, tree_node, name, &tree_len);
+		tree_val = fdt_getprop(fdto, tree_node, name, &tree_len);
 		if (!tree_val) {
 			if (tree_len == -FDT_ERR_NOTFOUND)
 				return -FDT_ERR_BADOVERLAY;
@@ -233,15 +252,33 @@ static int overlay_update_local_node_references(void *fdto,
 		}
 
 		for (i = 0; i < fixup_len; i++) {
-			fdt32_t *refp;
+			fdt32_t adj_val;
+			uint32_t poffset;
 
-			refp = (fdt32_t *)(tree_val + fdt32_ld_(fixup_val + i));
+			poffset = fdt32_to_cpu(fixup_val[i]);
 
 			/*
-			 * phandles to fixup can be unaligned, so use
-			 * fdt32_{ld,st}() to read/write them.
+			 * phandles to fixup can be unaligned.
+			 *
+			 * Use a memcpy for the architectures that do
+			 * not support unaligned accesses.
 			 */
-			fdt32_st(refp, fdt32_ld(refp) + delta);
+			memcpy(&adj_val, tree_val + poffset, sizeof(adj_val));
+
+			adj_val = cpu_to_fdt32(fdt32_to_cpu(adj_val) + delta);
+
+			ret = fdt_setprop_inplace_namelen_partial(fdto,
+								  tree_node,
+								  name,
+								  strlen(name),
+								  poffset,
+								  &adj_val,
+								  sizeof(adj_val));
+			if (ret == -FDT_ERR_NOSPACE)
+				return -FDT_ERR_BADOVERLAY;
+
+			if (ret)
+				return ret;
 		}
 	}
 
@@ -315,7 +352,7 @@ static int overlay_update_local_references(void *fdto, uint32_t delta)
  * @name: Name of the property holding the phandle reference in the overlay
  * @name_len: number of name characters to consider
  * @poffset: Offset within the overlay property where the phandle is stored
- * @phandle: Phandle referencing the node
+ * @label: Label of the node referenced by the phandle
  *
  * overlay_fixup_one_phandle() resolves an overlay phandle pointing to
  * a node in the base device tree.
@@ -332,14 +369,30 @@ static int overlay_fixup_one_phandle(void *fdt, void *fdto,
 				     int symbols_off,
 				     const char *path, uint32_t path_len,
 				     const char *name, uint32_t name_len,
-				     int poffset, uint32_t phandle)
+				     int poffset, const char *label)
 {
+	const char *symbol_path;
+	uint32_t phandle;
 	fdt32_t phandle_prop;
-	int fixup_off;
+	int symbol_off, fixup_off;
+	int prop_len;
 
 	if (symbols_off < 0)
 		return symbols_off;
 
+	symbol_path = fdt_getprop(fdt, symbols_off, label,
+				  &prop_len);
+	if (!symbol_path)
+		return prop_len;
+
+	symbol_off = fdt_path_offset(fdt, symbol_path);
+	if (symbol_off < 0)
+		return symbol_off;
+
+	phandle = fdt_get_phandle(fdt, symbol_off);
+	if (!phandle)
+		return -FDT_ERR_NOTFOUND;
+
 	fixup_off = fdt_path_offset_namelen(fdto, path, path_len);
 	if (fixup_off == -FDT_ERR_NOTFOUND)
 		return -FDT_ERR_BADOVERLAY;
@@ -378,10 +431,6 @@ static int overlay_fixup_phandle(void *fdt, void *fdto, int symbols_off,
 	const char *value;
 	const char *label;
 	int len;
-	const char *symbol_path;
-	int prop_len;
-	int symbol_off;
-	uint32_t phandle;
 
 	value = fdt_getprop_by_offset(fdto, property,
 				      &label, &len);
@@ -392,18 +441,6 @@ static int overlay_fixup_phandle(void *fdt, void *fdto, int symbols_off,
 		return len;
 	}
 
-	symbol_path = fdt_getprop(fdt, symbols_off, label, &prop_len);
-	if (!symbol_path)
-		return prop_len;
-	
-	symbol_off = fdt_path_offset(fdt, symbol_path);
-	if (symbol_off < 0)
-		return symbol_off;
-	
-	phandle = fdt_get_phandle(fdt, symbol_off);
-	if (!phandle)
-		return -FDT_ERR_NOTFOUND;
-
 	do {
 		const char *path, *name, *fixup_end;
 		const char *fixup_str = value;
@@ -445,7 +482,7 @@ static int overlay_fixup_phandle(void *fdt, void *fdto, int symbols_off,
 
 		ret = overlay_fixup_one_phandle(fdt, fdto, symbols_off,
 						path, path_len, name, name_len,
-						poffset, phandle);
+						poffset, label);
 		if (ret)
 			return ret;
 	} while (len > 0);
@@ -498,255 +535,6 @@ static int overlay_fixup_phandles(void *fdt, void *fdto)
 	return 0;
 }
 
-/**
- * overlay_adjust_local_conflicting_phandle: Changes a phandle value
- * @fdto: Device tree overlay
- * @node: The node the phandle is set for
- * @fdt_phandle: The new value for the phandle
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_adjust_local_conflicting_phandle(void *fdto, int node,
-						    uint32_t fdt_phandle)
-{
-	const fdt32_t *php;
-	int len, ret;
-
-	php = fdt_getprop(fdto, node, "phandle", &len);
-	if (php && len == sizeof(*php)) {
-		ret = fdt_setprop_inplace_u32(fdto, node, "phandle", fdt_phandle);
-		if (ret)
-			return ret;
-	}
-
-	php = fdt_getprop(fdto, node, "linux,phandle", &len);
-	if (php && len == sizeof(*php)) {
-		ret = fdt_setprop_inplace_u32(fdto, node, "linux,phandle", fdt_phandle);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-/**
- * overlay_update_node_conflicting_references - Recursively replace phandle values
- * @fdto: Device tree overlay blob
- * @tree_node: Node to recurse into
- * @fixup_node: Node offset of the matching local fixups node
- * @fdt_phandle: Value to replace phandles with
- * @fdto_phandle: Value to be replaced
- *
- * Replaces all phandles with value @fdto_phandle by @fdt_phandle.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_update_node_conflicting_references(void *fdto, int tree_node,
-						      int fixup_node,
-						      uint32_t fdt_phandle,
-						      uint32_t fdto_phandle)
-{
-	int fixup_prop;
-	int fixup_child;
-	int ret;
-
-	fdt_for_each_property_offset(fixup_prop, fdto, fixup_node) {
-		const fdt32_t *fixup_val;
-		const char *name;
-		char *tree_val;
-		int fixup_len;
-		int tree_len;
-		int i;
-
-		fixup_val = fdt_getprop_by_offset(fdto, fixup_prop,
-						  &name, &fixup_len);
-		if (!fixup_val)
-			return fixup_len;
-
-		if (fixup_len % sizeof(uint32_t))
-			return -FDT_ERR_BADOVERLAY;
-		fixup_len /= sizeof(uint32_t);
-
-		tree_val = fdt_getprop_w(fdto, tree_node, name, &tree_len);
-		if (!tree_val) {
-			if (tree_len == -FDT_ERR_NOTFOUND)
-				return -FDT_ERR_BADOVERLAY;
-
-			return tree_len;
-		}
-
-		for (i = 0; i < fixup_len; i++) {
-			fdt32_t *refp;
-			uint32_t valp;
-
-			refp = (fdt32_t *)(tree_val + fdt32_ld_(fixup_val + i));
-			valp = fdt32_ld(refp);
-
-			if (valp == fdto_phandle)
-				fdt32_st(refp, fdt_phandle);
-		}
-	}
-
-	fdt_for_each_subnode(fixup_child, fdto, fixup_node) {
-		const char *fixup_child_name = fdt_get_name(fdto, fixup_child, NULL);
-		int tree_child;
-
-		tree_child = fdt_subnode_offset(fdto, tree_node, fixup_child_name);
-
-		if (tree_child == -FDT_ERR_NOTFOUND)
-			return -FDT_ERR_BADOVERLAY;
-		if (tree_child < 0)
-			return tree_child;
-
-		ret = overlay_update_node_conflicting_references(fdto, tree_child,
-								 fixup_child,
-								 fdt_phandle,
-								 fdto_phandle);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-/**
- * overlay_update_local_conflicting_references - Recursively replace phandle values
- * @fdto: Device tree overlay blob
- * @fdt_phandle: Value to replace phandles with
- * @fdto_phandle: Value to be replaced
- *
- * Replaces all phandles with value @fdto_phandle by @fdt_phandle.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_update_local_conflicting_references(void *fdto,
-						       uint32_t fdt_phandle,
-						       uint32_t fdto_phandle)
-{
-	int fixups;
-
-	fixups = fdt_path_offset(fdto, "/__local_fixups__");
-	if (fixups == -FDT_ERR_NOTFOUND)
-		return 0;
-	if (fixups < 0)
-		return fixups;
-
-	return overlay_update_node_conflicting_references(fdto, 0, fixups,
-							  fdt_phandle,
-							  fdto_phandle);
-}
-
-/**
- * overlay_prevent_phandle_overwrite_node - Helper function for overlay_prevent_phandle_overwrite
- * @fdt: Base Device tree blob
- * @fdtnode: Node in fdt that is checked for an overwrite
- * @fdto: Device tree overlay blob
- * @fdtonode: Node in fdto matching @fdtnode
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_prevent_phandle_overwrite_node(void *fdt, int fdtnode,
-						  void *fdto, int fdtonode)
-{
-	uint32_t fdt_phandle, fdto_phandle;
-	int fdtochild;
-
-	fdt_phandle = fdt_get_phandle(fdt, fdtnode);
-	fdto_phandle = fdt_get_phandle(fdto, fdtonode);
-
-	if (fdt_phandle && fdto_phandle) {
-		int ret;
-
-		ret = overlay_adjust_local_conflicting_phandle(fdto, fdtonode,
-							       fdt_phandle);
-		if (ret)
-			return ret;
-
-		ret = overlay_update_local_conflicting_references(fdto,
-								  fdt_phandle,
-								  fdto_phandle);
-		if (ret)
-			return ret;
-	}
-
-	fdt_for_each_subnode(fdtochild, fdto, fdtonode) {
-		const char *name = fdt_get_name(fdto, fdtochild, NULL);
-		int fdtchild;
-		int ret;
-
-		fdtchild = fdt_subnode_offset(fdt, fdtnode, name);
-		if (fdtchild == -FDT_ERR_NOTFOUND)
-			/*
-			 * no further overwrites possible here as this node is
-			 * new
-			 */
-			continue;
-
-		ret = overlay_prevent_phandle_overwrite_node(fdt, fdtchild,
-							     fdto, fdtochild);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-/**
- * overlay_prevent_phandle_overwrite - Fixes overlay phandles to not overwrite base phandles
- * @fdt: Base Device Tree blob
- * @fdto: Device tree overlay blob
- *
- * Checks recursively if applying fdto overwrites phandle values in the base
- * dtb. When such a phandle is found, the fdto is changed to use the fdt's
- * phandle value to not break references in the base.
- *
- * returns:
- *      0 on success
- *      Negative error code on failure
- */
-static int overlay_prevent_phandle_overwrite(void *fdt, void *fdto)
-{
-	int fragment;
-
-	fdt_for_each_subnode(fragment, fdto, 0) {
-		int overlay;
-		int target;
-		int ret;
-
-		overlay = fdt_subnode_offset(fdto, fragment, "__overlay__");
-		if (overlay == -FDT_ERR_NOTFOUND)
-			continue;
-
-		if (overlay < 0)
-			return overlay;
-
-		target = fdt_overlay_target_offset(fdt, fdto, fragment, NULL);
-		if (target == -FDT_ERR_NOTFOUND)
-			/*
-			 * The subtree doesn't exist in the base, so nothing
-			 * will be overwritten.
-			 */
-			continue;
-		else if (target < 0)
-			return target;
-
-		ret = overlay_prevent_phandle_overwrite_node(fdt, target,
-							     fdto, overlay);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
 /**
  * overlay_apply_node - Merges a node into the base device tree
  * @fdt: Base Device Tree blob
@@ -848,7 +636,7 @@ static int overlay_merge(void *fdt, void *fdto)
 		if (overlay < 0)
 			return overlay;
 
-		target = fdt_overlay_target_offset(fdt, fdto, fragment, NULL);
+		target = overlay_get_target(fdt, fdto, fragment, NULL);
 		if (target < 0)
 			return target;
 
@@ -991,7 +779,7 @@ static int overlay_symbol_update(void *fdt, void *fdto)
 			return -FDT_ERR_BADOVERLAY;
 
 		/* get the target of the fragment */
-		ret = fdt_overlay_target_offset(fdt, fdto, fragment, &target_path);
+		ret = overlay_get_target(fdt, fdto, fragment, &target_path);
 		if (ret < 0)
 			return ret;
 		target = ret;
@@ -1013,7 +801,7 @@ static int overlay_symbol_update(void *fdt, void *fdto)
 
 		if (!target_path) {
 			/* again in case setprop_placeholder changed it */
-			ret = fdt_overlay_target_offset(fdt, fdto, fragment, &target_path);
+			ret = overlay_get_target(fdt, fdto, fragment, &target_path);
 			if (ret < 0)
 				return ret;
 			target = ret;
@@ -1051,26 +839,18 @@ int fdt_overlay_apply(void *fdt, void *fdto)
 	if (ret)
 		goto err;
 
-	/* Increase all phandles in the fdto by delta */
 	ret = overlay_adjust_local_phandles(fdto, delta);
 	if (ret)
 		goto err;
 
-	/* Adapt the phandle values in fdto to the above increase */
 	ret = overlay_update_local_references(fdto, delta);
 	if (ret)
 		goto err;
 
-	/* Update fdto's phandles using symbols from fdt */
 	ret = overlay_fixup_phandles(fdt, fdto);
 	if (ret)
 		goto err;
 
-	/* Don't overwrite phandles in fdt */
-	ret = overlay_prevent_phandle_overwrite(fdt, fdto);
-	if (ret)
-		goto err;
-
 	ret = overlay_merge(fdt, fdto);
 	if (ret)
 		goto err;
diff --git a/scripts/dtc/libfdt/fdt_ro.c b/scripts/dtc/libfdt/fdt_ro.c
index b78c4e48f1cb..91cc6fefe374 100644
--- a/scripts/dtc/libfdt/fdt_ro.c
+++ b/scripts/dtc/libfdt/fdt_ro.c
@@ -181,8 +181,8 @@ int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size)
 	if (!can_assume(VALID_INPUT) && !re)
 		return -FDT_ERR_BADOFFSET;
 
-	*address = fdt64_ld_(&re->address);
-	*size = fdt64_ld_(&re->size);
+	*address = fdt64_ld(&re->address);
+	*size = fdt64_ld(&re->size);
 	return 0;
 }
 
@@ -192,7 +192,7 @@ int fdt_num_mem_rsv(const void *fdt)
 	const struct fdt_reserve_entry *re;
 
 	for (i = 0; (re = fdt_mem_rsv(fdt, i)) != NULL; i++) {
-		if (fdt64_ld_(&re->size) == 0)
+		if (fdt64_ld(&re->size) == 0)
 			return i;
 	}
 	return -FDT_ERR_TRUNCATED;
@@ -255,9 +255,6 @@ int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen)
 
 	FDT_RO_PROBE(fdt);
 
-	if (!can_assume(VALID_INPUT) && namelen <= 0)
-		return -FDT_ERR_BADPATH;
-
 	/* see if we have an alias */
 	if (*path != '/') {
 		const char *q = memchr(path, '/', end - p);
@@ -373,7 +370,7 @@ static const struct fdt_property *fdt_get_property_by_offset_(const void *fdt,
 	prop = fdt_offset_ptr_(fdt, offset);
 
 	if (lenp)
-		*lenp = fdt32_ld_(&prop->len);
+		*lenp = fdt32_ld(&prop->len);
 
 	return prop;
 }
@@ -411,7 +408,7 @@ static const struct fdt_property *fdt_get_property_namelen_(const void *fdt,
 			offset = -FDT_ERR_INTERNAL;
 			break;
 		}
-		if (fdt_string_eq_(fdt, fdt32_ld_(&prop->nameoff),
+		if (fdt_string_eq_(fdt, fdt32_ld(&prop->nameoff),
 				   name, namelen)) {
 			if (poffset)
 				*poffset = offset;
@@ -464,7 +461,7 @@ const void *fdt_getprop_namelen(const void *fdt, int nodeoffset,
 
 	/* Handle realignment */
 	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10 &&
-	    (poffset + sizeof(*prop)) % 8 && fdt32_ld_(&prop->len) >= 8)
+	    (poffset + sizeof(*prop)) % 8 && fdt32_ld(&prop->len) >= 8)
 		return prop->data + 4;
 	return prop->data;
 }
@@ -482,22 +479,22 @@ const void *fdt_getprop_by_offset(const void *fdt, int offset,
 		int namelen;
 
 		if (!can_assume(VALID_INPUT)) {
-			name = fdt_get_string(fdt, fdt32_ld_(&prop->nameoff),
+			name = fdt_get_string(fdt, fdt32_ld(&prop->nameoff),
 					      &namelen);
-			*namep = name;
 			if (!name) {
 				if (lenp)
 					*lenp = namelen;
 				return NULL;
 			}
+			*namep = name;
 		} else {
-			*namep = fdt_string(fdt, fdt32_ld_(&prop->nameoff));
+			*namep = fdt_string(fdt, fdt32_ld(&prop->nameoff));
 		}
 	}
 
 	/* Handle realignment */
 	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10 &&
-	    (offset + sizeof(*prop)) % 8 && fdt32_ld_(&prop->len) >= 8)
+	    (offset + sizeof(*prop)) % 8 && fdt32_ld(&prop->len) >= 8)
 		return prop->data + 4;
 	return prop->data;
 }
@@ -522,34 +519,19 @@ uint32_t fdt_get_phandle(const void *fdt, int nodeoffset)
 			return 0;
 	}
 
-	return fdt32_ld_(php);
-}
-
-static const void *fdt_path_getprop_namelen(const void *fdt, const char *path,
-					    const char *propname, int propnamelen,
-					    int *lenp)
-{
-	int offset = fdt_path_offset(fdt, path);
-
-	if (offset < 0)
-		return NULL;
-
-	return fdt_getprop_namelen(fdt, offset, propname, propnamelen, lenp);
+	return fdt32_ld(php);
 }
 
 const char *fdt_get_alias_namelen(const void *fdt,
 				  const char *name, int namelen)
 {
-	int len;
-	const char *alias;
-
-	alias = fdt_path_getprop_namelen(fdt, "/aliases", name, namelen, &len);
+	int aliasoffset;
 
-	if (!can_assume(VALID_DTB) &&
-	    !(alias && len > 0 && alias[len - 1] == '\0' && *alias == '/'))
+	aliasoffset = fdt_path_offset(fdt, "/aliases");
+	if (aliasoffset < 0)
 		return NULL;
 
-	return alias;
+	return fdt_getprop_namelen(fdt, aliasoffset, name, namelen, NULL);
 }
 
 const char *fdt_get_alias(const void *fdt, const char *name)
@@ -557,17 +539,6 @@ const char *fdt_get_alias(const void *fdt, const char *name)
 	return fdt_get_alias_namelen(fdt, name, strlen(name));
 }
 
-const char *fdt_get_symbol_namelen(const void *fdt,
-				   const char *name, int namelen)
-{
-	return fdt_path_getprop_namelen(fdt, "/__symbols__", name, namelen, NULL);
-}
-
-const char *fdt_get_symbol(const void *fdt, const char *name)
-{
-	return fdt_get_symbol_namelen(fdt, name, strlen(name));
-}
-
 int fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen)
 {
 	int pdepth = 0, p = 0;
diff --git a/scripts/dtc/libfdt/fdt_rw.c b/scripts/dtc/libfdt/fdt_rw.c
index 3621d3651d3f..68887b969a45 100644
--- a/scripts/dtc/libfdt/fdt_rw.c
+++ b/scripts/dtc/libfdt/fdt_rw.c
@@ -349,10 +349,7 @@ int fdt_add_subnode_namelen(void *fdt, int parentoffset,
 		return offset;
 
 	/* Try to place the new node after the parent's properties */
-	tag = fdt_next_tag(fdt, parentoffset, &nextoffset);
-	/* the fdt_subnode_offset_namelen() should ensure this never hits */
-	if (!can_assume(LIBFDT_FLAWLESS) && (tag != FDT_BEGIN_NODE))
-		return -FDT_ERR_INTERNAL;
+	fdt_next_tag(fdt, parentoffset, &nextoffset); /* skip the BEGIN_NODE */
 	do {
 		offset = nextoffset;
 		tag = fdt_next_tag(fdt, offset, &nextoffset);
@@ -394,9 +391,7 @@ int fdt_del_node(void *fdt, int nodeoffset)
 }
 
 static void fdt_packblocks_(const char *old, char *new,
-			    int mem_rsv_size,
-			    int struct_size,
-			    int strings_size)
+			    int mem_rsv_size, int struct_size)
 {
 	int mem_rsv_off, struct_off, strings_off;
 
@@ -411,7 +406,8 @@ static void fdt_packblocks_(const char *old, char *new,
 	fdt_set_off_dt_struct(new, struct_off);
 	fdt_set_size_dt_struct(new, struct_size);
 
-	memmove(new + strings_off, old + fdt_off_dt_strings(old), strings_size);
+	memmove(new + strings_off, old + fdt_off_dt_strings(old),
+		fdt_size_dt_strings(old));
 	fdt_set_off_dt_strings(new, strings_off);
 	fdt_set_size_dt_strings(new, fdt_size_dt_strings(old));
 }
@@ -432,14 +428,12 @@ int fdt_open_into(const void *fdt, void *buf, int bufsize)
 
 	if (can_assume(LATEST) || fdt_version(fdt) >= 17) {
 		struct_size = fdt_size_dt_struct(fdt);
-	} else if (fdt_version(fdt) == 16) {
+	} else {
 		struct_size = 0;
 		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
 			;
 		if (struct_size < 0)
 			return struct_size;
-	} else {
-		return -FDT_ERR_BADVERSION;
 	}
 
 	if (can_assume(LIBFDT_ORDER) ||
@@ -471,8 +465,7 @@ int fdt_open_into(const void *fdt, void *buf, int bufsize)
 			return -FDT_ERR_NOSPACE;
 	}
 
-	fdt_packblocks_(fdt, tmp, mem_rsv_size, struct_size,
-			fdt_size_dt_strings(fdt));
+	fdt_packblocks_(fdt, tmp, mem_rsv_size, struct_size);
 	memmove(buf, tmp, newsize);
 
 	fdt_set_magic(buf, FDT_MAGIC);
@@ -492,8 +485,7 @@ int fdt_pack(void *fdt)
 
 	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
 		* sizeof(struct fdt_reserve_entry);
-	fdt_packblocks_(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt),
-			fdt_size_dt_strings(fdt));
+	fdt_packblocks_(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));
 	fdt_set_totalsize(fdt, fdt_data_size_(fdt));
 
 	return 0;
diff --git a/scripts/dtc/libfdt/fdt_strerror.c b/scripts/dtc/libfdt/fdt_strerror.c
index d852b77e81e7..b4356931b06d 100644
--- a/scripts/dtc/libfdt/fdt_strerror.c
+++ b/scripts/dtc/libfdt/fdt_strerror.c
@@ -39,7 +39,6 @@ static struct fdt_errtabent fdt_errtable[] = {
 	FDT_ERRTABENT(FDT_ERR_BADOVERLAY),
 	FDT_ERRTABENT(FDT_ERR_NOPHANDLES),
 	FDT_ERRTABENT(FDT_ERR_BADFLAGS),
-	FDT_ERRTABENT(FDT_ERR_ALIGNMENT),
 };
 #define FDT_ERRTABSIZE	((int)(sizeof(fdt_errtable) / sizeof(fdt_errtable[0])))
 
diff --git a/scripts/dtc/libfdt/fdt_sw.c b/scripts/dtc/libfdt/fdt_sw.c
index 4c569ee7eb0d..68b543c4dfa2 100644
--- a/scripts/dtc/libfdt/fdt_sw.c
+++ b/scripts/dtc/libfdt/fdt_sw.c
@@ -377,7 +377,7 @@ int fdt_finish(void *fdt)
 	fdt_set_totalsize(fdt, newstroffset + fdt_size_dt_strings(fdt));
 
 	/* And fix up fields that were keeping intermediate state. */
-	fdt_set_last_comp_version(fdt, FDT_LAST_COMPATIBLE_VERSION);
+	fdt_set_last_comp_version(fdt, FDT_FIRST_SUPPORTED_VERSION);
 	fdt_set_magic(fdt, FDT_MAGIC);
 
 	return 0;
diff --git a/scripts/dtc/libfdt/libfdt.h b/scripts/dtc/libfdt/libfdt.h
index 2d409d8e829b..fe49b5d78938 100644
--- a/scripts/dtc/libfdt/libfdt.h
+++ b/scripts/dtc/libfdt/libfdt.h
@@ -14,7 +14,6 @@ extern "C" {
 #endif
 
 #define FDT_FIRST_SUPPORTED_VERSION	0x02
-#define FDT_LAST_COMPATIBLE_VERSION 0x10
 #define FDT_LAST_SUPPORTED_VERSION	0x11
 
 /* Error codes: informative error codes */
@@ -102,11 +101,7 @@ extern "C" {
 	/* FDT_ERR_BADFLAGS: The function was passed a flags field that
 	 * contains invalid flags or an invalid combination of flags. */
 
-#define FDT_ERR_ALIGNMENT	19
-	/* FDT_ERR_ALIGNMENT: The device tree base address is not 8-byte
-	 * aligned. */
-
-#define FDT_ERR_MAX		19
+#define FDT_ERR_MAX		18
 
 /* constants */
 #define FDT_MAX_PHANDLE 0xfffffffe
@@ -127,16 +122,11 @@ static inline void *fdt_offset_ptr_w(void *fdt, int offset, int checklen)
 uint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset);
 
 /*
- * External helpers to access words from a device tree blob. They're built
- * to work even with unaligned pointers on platforms (such as ARMv5) that don't
- * like unaligned loads and stores.
+ * Alignment helpers:
+ *     These helpers access words from a device tree blob.  They're
+ *     built to work even with unaligned pointers on platforms (ike
+ *     ARM) that don't like unaligned loads and stores
  */
-static inline uint16_t fdt16_ld(const fdt16_t *p)
-{
-	const uint8_t *bp = (const uint8_t *)p;
-
-	return ((uint16_t)bp[0] << 8) | bp[1];
-}
 
 static inline uint32_t fdt32_ld(const fdt32_t *p)
 {
@@ -194,23 +184,23 @@ int fdt_next_node(const void *fdt, int offset, int *depth);
 
 /**
  * fdt_first_subnode() - get offset of first direct subnode
+ *
  * @fdt:	FDT blob
  * @offset:	Offset of node to check
- *
- * Return: offset of first subnode, or -FDT_ERR_NOTFOUND if there is none
+ * @return offset of first subnode, or -FDT_ERR_NOTFOUND if there is none
  */
 int fdt_first_subnode(const void *fdt, int offset);
 
 /**
  * fdt_next_subnode() - get offset of next direct subnode
- * @fdt:	FDT blob
- * @offset:	Offset of previous subnode
  *
  * After first calling fdt_first_subnode(), call this function repeatedly to
  * get direct subnodes of a parent node.
  *
- * Return: offset of next subnode, or -FDT_ERR_NOTFOUND if there are no more
- *         subnodes
+ * @fdt:	FDT blob
+ * @offset:	Offset of previous subnode
+ * @return offset of next subnode, or -FDT_ERR_NOTFOUND if there are no more
+ * subnodes
  */
 int fdt_next_subnode(const void *fdt, int offset);
 
@@ -235,6 +225,7 @@ int fdt_next_subnode(const void *fdt, int offset);
  * Note that this is implemented as a macro and @node is used as
  * iterator in the loop. The parent variable be constant or even a
  * literal.
+ *
  */
 #define fdt_for_each_subnode(node, fdt, parent)		\
 	for (node = fdt_first_subnode(fdt, parent);	\
@@ -278,21 +269,17 @@ fdt_set_hdr_(size_dt_struct);
 /**
  * fdt_header_size - return the size of the tree's header
  * @fdt: pointer to a flattened device tree
- *
- * Return: size of DTB header in bytes
  */
 size_t fdt_header_size(const void *fdt);
 
 /**
- * fdt_header_size_ - internal function to get header size from a version number
- * @version: devicetree version number
- *
- * Return: size of DTB header in bytes
+ * fdt_header_size_ - internal function which takes a version number
  */
 size_t fdt_header_size_(uint32_t version);
 
 /**
  * fdt_check_header - sanity check a device tree header
+
  * @fdt: pointer to data which might be a flattened device tree
  *
  * fdt_check_header() checks that the given buffer contains what
@@ -417,7 +404,8 @@ static inline uint32_t fdt_get_max_phandle(const void *fdt)
  * highest phandle value in the device tree blob) will be returned in the
  * @phandle parameter.
  *
- * Return: 0 on success or a negative error-code on failure
+ * Returns:
+ *   0 on success or a negative error-code on failure
  */
 int fdt_generate_phandle(const void *fdt, uint32_t *phandle);
 
@@ -437,11 +425,9 @@ int fdt_num_mem_rsv(const void *fdt);
 /**
  * fdt_get_mem_rsv - retrieve one memory reserve map entry
  * @fdt: pointer to the device tree blob
- * @n: index of reserve map entry
- * @address: pointer to 64-bit variable to hold the start address
- * @size: pointer to 64-bit variable to hold the size of the entry
+ * @address, @size: pointers to 64-bit variables
  *
- * On success, @address and @size will contain the address and size of
+ * On success, *address and *size will contain the address and size of
  * the n-th reserve map entry from the device tree blob, in
  * native-endian format.
  *
@@ -464,8 +450,6 @@ int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size);
  * namelen characters of name for matching the subnode name.  This is
  * useful for finding subnodes based on a portion of a larger string,
  * such as a full path.
- *
- * Return: offset of the subnode or -FDT_ERR_NOTFOUND if name not found.
  */
 #ifndef SWIG /* Not available in Python */
 int fdt_subnode_offset_namelen(const void *fdt, int parentoffset,
@@ -505,8 +489,6 @@ int fdt_subnode_offset(const void *fdt, int parentoffset, const char *name);
  *
  * Identical to fdt_path_offset(), but only consider the first namelen
  * characters of path as the path name.
- *
- * Return: offset of the node or negative libfdt error value otherwise
  */
 #ifndef SWIG /* Not available in Python */
 int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen);
@@ -524,35 +506,10 @@ int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen);
  * level matching the given component, differentiated only by unit
  * address).
  *
- * If the path is not absolute (i.e. does not begin with '/'), the
- * first component is treated as an alias.  That is, the property by
- * that name is looked up in the /aliases node, and the value of that
- * property used in place of that first component.
- *
- * For example, for this small fragment
- *
- * / {
- *     aliases {
- *         i2c2 = &foo; // RHS compiles to "/soc@0/i2c@30a40000/eeprom@52"
- *     };
- *     soc@0 {
- *         foo: i2c@30a40000 {
- *             bar: eeprom@52 {
- *             };
- *         };
- *     };
- * };
- *
- * these would be equivalent:
- *
- *   /soc@0/i2c@30a40000/eeprom@52
- *   i2c2/eeprom@52
- *
  * returns:
  *	structure block offset of the node with the requested path (>=0), on
  *		success
- *	-FDT_ERR_BADPATH, given path does not begin with '/' and the first
- *		component is not a valid alias
+ *	-FDT_ERR_BADPATH, given path does not begin with '/' or is invalid
  *	-FDT_ERR_NOTFOUND, if the requested node does not exist
  *      -FDT_ERR_BADMAGIC,
  *	-FDT_ERR_BADVERSION,
@@ -631,9 +588,9 @@ int fdt_next_property_offset(const void *fdt, int offset);
 /**
  * fdt_for_each_property_offset - iterate over all properties of a node
  *
- * @property:	property offset (int, lvalue)
- * @fdt:	FDT blob (const void *)
- * @node:	node offset (int)
+ * @property_offset:	property offset (int, lvalue)
+ * @fdt:		FDT blob (const void *)
+ * @node:		node offset (int)
  *
  * This is actually a wrapper around a for loop and would be used like so:
  *
@@ -685,13 +642,6 @@ int fdt_next_property_offset(const void *fdt, int offset);
 const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
 						      int offset,
 						      int *lenp);
-static inline struct fdt_property *fdt_get_property_by_offset_w(void *fdt,
-								int offset,
-								int *lenp)
-{
-	return (struct fdt_property *)(uintptr_t)
-		fdt_get_property_by_offset(fdt, offset, lenp);
-}
 
 /**
  * fdt_get_property_namelen - find a property based on substring
@@ -703,9 +653,6 @@ static inline struct fdt_property *fdt_get_property_by_offset_w(void *fdt,
  *
  * Identical to fdt_get_property(), but only examine the first namelen
  * characters of name for matching the property name.
- *
- * Return: pointer to the structure representing the property, or NULL
- *         if not found
  */
 #ifndef SWIG /* Not available in Python */
 const struct fdt_property *fdt_get_property_namelen(const void *fdt,
@@ -798,8 +745,6 @@ const void *fdt_getprop_by_offset(const void *fdt, int offset,
  *
  * Identical to fdt_getprop(), but only examine the first namelen
  * characters of name for matching the property name.
- *
- * Return: pointer to the property's value or NULL on error
  */
 #ifndef SWIG /* Not available in Python */
 const void *fdt_getprop_namelen(const void *fdt, int nodeoffset,
@@ -821,10 +766,10 @@ static inline void *fdt_getprop_namelen_w(void *fdt, int nodeoffset,
  * @lenp: pointer to an integer variable (will be overwritten) or NULL
  *
  * fdt_getprop() retrieves a pointer to the value of the property
- * named @name of the node at offset @nodeoffset (this will be a
+ * named 'name' of the node at offset nodeoffset (this will be a
  * pointer to within the device blob itself, not a copy of the value).
- * If @lenp is non-NULL, the length of the property value is also
- * returned, in the integer pointed to by @lenp.
+ * If lenp is non-NULL, the length of the property value is also
+ * returned, in the integer pointed to by lenp.
  *
  * returns:
  *	pointer to the property's value
@@ -869,11 +814,8 @@ uint32_t fdt_get_phandle(const void *fdt, int nodeoffset);
  * @name: name of the alias th look up
  * @namelen: number of characters of name to consider
  *
- * Identical to fdt_get_alias(), but only examine the first @namelen
- * characters of @name for matching the alias name.
- *
- * Return: a pointer to the expansion of the alias named @name, if it exists,
- *	   NULL otherwise
+ * Identical to fdt_get_alias(), but only examine the first namelen
+ * characters of name for matching the alias name.
  */
 #ifndef SWIG /* Not available in Python */
 const char *fdt_get_alias_namelen(const void *fdt,
@@ -886,7 +828,7 @@ const char *fdt_get_alias_namelen(const void *fdt,
  * @name: name of the alias th look up
  *
  * fdt_get_alias() retrieves the value of a given alias.  That is, the
- * value of the property named @name in the node /aliases.
+ * value of the property named 'name' in the node /aliases.
  *
  * returns:
  *	a pointer to the expansion of the alias named 'name', if it exists
@@ -894,42 +836,6 @@ const char *fdt_get_alias_namelen(const void *fdt,
  */
 const char *fdt_get_alias(const void *fdt, const char *name);
 
-/**
- * fdt_get_symbol_namelen - get symbol based on substring
- * @fdt: pointer to the device tree blob
- * @name: name of the symbol to look up
- * @namelen: number of characters of name to consider
- *
- * Identical to fdt_get_symbol(), but only examine the first @namelen
- * characters of @name for matching the symbol name.
- *
- * Return: a pointer to the expansion of the symbol named @name, if it exists,
- *	   NULL otherwise
- */
-#ifndef SWIG /* Not available in Python */
-const char *fdt_get_symbol_namelen(const void *fdt,
-				   const char *name, int namelen);
-#endif
-
-/**
- * fdt_get_symbol - retrieve the path referenced by a given symbol
- * @fdt: pointer to the device tree blob
- * @name: name of the symbol to look up
- *
- * fdt_get_symbol() retrieves the value of a given symbol.  That is,
- * the value of the property named @name in the node
- * /__symbols__. Such a node exists only for a device tree blob that
- * has been compiled with the -@ dtc option. Each property corresponds
- * to a label appearing in the device tree source, with the name of
- * the property being the label and the value being the full path of
- * the node it is attached to.
- *
- * returns:
- *	a pointer to the expansion of the symbol named 'name', if it exists
- *	NULL, if the given symbol or the /__symbols__ node does not exist
- */
-const char *fdt_get_symbol(const void *fdt, const char *name);
-
 /**
  * fdt_get_path - determine the full path of a node
  * @fdt: pointer to the device tree blob
@@ -1098,13 +1004,14 @@ int fdt_node_offset_by_prop_value(const void *fdt, int startoffset,
 int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle);
 
 /**
- * fdt_node_check_compatible - check a node's compatible property
+ * fdt_node_check_compatible: check a node's compatible property
  * @fdt: pointer to the device tree blob
  * @nodeoffset: offset of a tree node
  * @compatible: string to match against
  *
+ *
  * fdt_node_check_compatible() returns 0 if the given node contains a
- * @compatible property with the given string as one of its elements,
+ * 'compatible' property with the given string as one of its elements,
  * it returns non-zero otherwise, or on error.
  *
  * returns:
@@ -1168,7 +1075,7 @@ int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
  * one or more strings, each terminated by \0, as is found in a device tree
  * "compatible" property.
  *
- * Return: 1 if the string is found in the list, 0 not found, or invalid list
+ * @return: 1 if the string is found in the list, 0 not found, or invalid list
  */
 int fdt_stringlist_contains(const char *strlist, int listlen, const char *str);
 
@@ -1177,8 +1084,7 @@ int fdt_stringlist_contains(const char *strlist, int listlen, const char *str);
  * @fdt: pointer to the device tree blob
  * @nodeoffset: offset of a tree node
  * @property: name of the property containing the string list
- *
- * Return:
+ * @return:
  *   the number of strings in the given property
  *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
  *   -FDT_ERR_NOTFOUND if the property does not exist
@@ -1198,7 +1104,7 @@ int fdt_stringlist_count(const void *fdt, int nodeoffset, const char *property);
  * small-valued cell properties, such as #address-cells, when searching for
  * the empty string.
  *
- * return:
+ * @return:
  *   the index of the string in the list of strings
  *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
  *   -FDT_ERR_NOTFOUND if the property does not exist or does not contain
@@ -1222,7 +1128,7 @@ int fdt_stringlist_search(const void *fdt, int nodeoffset, const char *property,
  * If non-NULL, the length of the string (on success) or a negative error-code
  * (on failure) will be stored in the integer pointer to by lenp.
  *
- * Return:
+ * @return:
  *   A pointer to the string at the given index in the string list or NULL on
  *   failure. On success the length of the string will be stored in the memory
  *   location pointed to by the lenp parameter, if non-NULL. On failure one of
@@ -1311,8 +1217,6 @@ int fdt_size_cells(const void *fdt, int nodeoffset);
  * starting from the given index, and using only the first characters
  * of the name. It is useful when you want to manipulate only one value of
  * an array and you have a string that doesn't end with \0.
- *
- * Return: 0 on success, negative libfdt error value otherwise
  */
 #ifndef SWIG /* Not available in Python */
 int fdt_setprop_inplace_namelen_partial(void *fdt, int nodeoffset,
@@ -1426,13 +1330,8 @@ static inline int fdt_setprop_inplace_u64(void *fdt, int nodeoffset,
 
 /**
  * fdt_setprop_inplace_cell - change the value of a single-cell property
- * @fdt: pointer to the device tree blob
- * @nodeoffset: offset of the node containing the property
- * @name: name of the property to change the value of
- * @val: new value of the 32-bit cell
  *
  * This is an alternative name for fdt_setprop_inplace_u32()
- * Return: 0 on success, negative libfdt error number otherwise.
  */
 static inline int fdt_setprop_inplace_cell(void *fdt, int nodeoffset,
 					   const char *name, uint32_t val)
@@ -1504,14 +1403,14 @@ int fdt_nop_node(void *fdt, int nodeoffset);
 
 /**
  * fdt_create_with_flags - begin creation of a new fdt
- * @buf: pointer to memory allocated where fdt will be created
+ * @fdt: pointer to memory allocated where fdt will be created
  * @bufsize: size of the memory space at fdt
  * @flags: a valid combination of FDT_CREATE_FLAG_ flags, or 0.
  *
  * fdt_create_with_flags() begins the process of creating a new fdt with
  * the sequential write interface.
  *
- * fdt creation process must end with fdt_finish() to produce a valid fdt.
+ * fdt creation process must end with fdt_finished() to produce a valid fdt.
  *
  * returns:
  *	0, on success
@@ -1522,7 +1421,7 @@ int fdt_create_with_flags(void *buf, int bufsize, uint32_t flags);
 
 /**
  * fdt_create - begin creation of a new fdt
- * @buf: pointer to memory allocated where fdt will be created
+ * @fdt: pointer to memory allocated where fdt will be created
  * @bufsize: size of the memory space at fdt
  *
  * fdt_create() is equivalent to fdt_create_with_flags() with flags=0.
@@ -1587,8 +1486,7 @@ int fdt_pack(void *fdt);
 /**
  * fdt_add_mem_rsv - add one memory reserve map entry
  * @fdt: pointer to the device tree blob
- * @address: 64-bit start address of the reserve map entry
- * @size: 64-bit size of the reserved region
+ * @address, @size: 64-bit values (native endian)
  *
  * Adds a reserve map entry to the given blob reserving a region at
  * address address of length size.
@@ -1793,14 +1691,8 @@ static inline int fdt_setprop_u64(void *fdt, int nodeoffset, const char *name,
 
 /**
  * fdt_setprop_cell - set a property to a single cell value
- * @fdt: pointer to the device tree blob
- * @nodeoffset: offset of the node whose property to change
- * @name: name of the property to change
- * @val: 32-bit integer value for the property (native endian)
  *
  * This is an alternative name for fdt_setprop_u32()
- *
- * Return: 0 on success, negative libfdt error value otherwise.
  */
 static inline int fdt_setprop_cell(void *fdt, int nodeoffset, const char *name,
 				   uint32_t val)
@@ -1971,14 +1863,8 @@ static inline int fdt_appendprop_u64(void *fdt, int nodeoffset,
 
 /**
  * fdt_appendprop_cell - append a single cell value to a property
- * @fdt: pointer to the device tree blob
- * @nodeoffset: offset of the node whose property to change
- * @name: name of the property to change
- * @val: 32-bit integer value to append to the property (native endian)
  *
  * This is an alternative name for fdt_appendprop_u32()
- *
- * Return: 0 on success, negative libfdt error value otherwise.
  */
 static inline int fdt_appendprop_cell(void *fdt, int nodeoffset,
 				      const char *name, uint32_t val)
@@ -2029,7 +1915,7 @@ static inline int fdt_appendprop_cell(void *fdt, int nodeoffset,
  * address and size) to the value of the named property in the given
  * node, or creates a new property with that value if it does not
  * already exist.
- *
+ * If "name" is not specified, a default "reg" is used.
  * Cell sizes are determined by parent's #address-cells and #size-cells.
  *
  * This function may insert data into the blob, and will therefore
@@ -2081,16 +1967,13 @@ int fdt_delprop(void *fdt, int nodeoffset, const char *name);
  * fdt_add_subnode_namelen - creates a new node based on substring
  * @fdt: pointer to the device tree blob
  * @parentoffset: structure block offset of a node
- * @name: name of the subnode to create
+ * @name: name of the subnode to locate
  * @namelen: number of characters of name to consider
  *
- * Identical to fdt_add_subnode(), but use only the first @namelen
- * characters of @name as the name of the new node.  This is useful for
+ * Identical to fdt_add_subnode(), but use only the first namelen
+ * characters of name as the name of the new node.  This is useful for
  * creating subnodes based on a portion of a larger string, such as a
  * full path.
- *
- * Return: structure block offset of the created subnode (>=0),
- *	   negative libfdt error value otherwise
  */
 #ifndef SWIG /* Not available in Python */
 int fdt_add_subnode_namelen(void *fdt, int parentoffset,
@@ -2109,7 +1992,7 @@ int fdt_add_subnode_namelen(void *fdt, int parentoffset,
  *
  * This function will insert data into the blob, and will therefore
  * change the offsets of some existing nodes.
- *
+
  * returns:
  *	structure block offset of the created nodeequested subnode (>=0), on
  *		success
@@ -2184,24 +2067,6 @@ int fdt_del_node(void *fdt, int nodeoffset);
  */
 int fdt_overlay_apply(void *fdt, void *fdto);
 
-/**
- * fdt_overlay_target_offset - retrieves the offset of a fragment's target
- * @fdt: Base device tree blob
- * @fdto: Device tree overlay blob
- * @fragment_offset: node offset of the fragment in the overlay
- * @pathp: pointer which receives the path of the target (or NULL)
- *
- * fdt_overlay_target_offset() retrieves the target offset in the base
- * device tree of a fragment, no matter how the actual targeting is
- * done (through a phandle or a path)
- *
- * returns:
- *      the targeted node offset in the base device tree
- *      Negative error code on error
- */
-int fdt_overlay_target_offset(const void *fdt, const void *fdto,
-			      int fragment_offset, char const **pathp);
-
 /**********************************************************************/
 /* Debugging / informational functions                                */
 /**********************************************************************/
diff --git a/scripts/dtc/libfdt/libfdt_internal.h b/scripts/dtc/libfdt/libfdt_internal.h
index 16bda1906a7b..d4e0bd49c037 100644
--- a/scripts/dtc/libfdt/libfdt_internal.h
+++ b/scripts/dtc/libfdt/libfdt_internal.h
@@ -46,25 +46,6 @@ static inline struct fdt_reserve_entry *fdt_mem_rsv_w_(void *fdt, int n)
 	return (void *)(uintptr_t)fdt_mem_rsv_(fdt, n);
 }
 
-/*
- * Internal helpers to access tructural elements of the device tree
- * blob (rather than for exaple reading integers from within property
- * values).  We assume that we are either given a naturally aligned
- * address for the platform or if we are not, we are on a platform
- * where unaligned memory reads will be handled in a graceful manner.
- * If not the external helpers fdtXX_ld() from libfdt.h can be used
- * instead.
- */
-static inline uint32_t fdt32_ld_(const fdt32_t *p)
-{
-	return fdt32_to_cpu(*p);
-}
-
-static inline uint64_t fdt64_ld_(const fdt64_t *p)
-{
-	return fdt64_to_cpu(*p);
-}
-
 #define FDT_SW_MAGIC		(~FDT_MAGIC)
 
 /**********************************************************************/
diff --git a/scripts/dtc/livetree.c b/scripts/dtc/livetree.c
index 49f723002f85..032df5878ccc 100644
--- a/scripts/dtc/livetree.c
+++ b/scripts/dtc/livetree.c
@@ -36,27 +36,27 @@ void delete_labels(struct label **labels)
 		label->deleted = 1;
 }
 
-struct property *build_property(const char *name, struct data val,
+struct property *build_property(char *name, struct data val,
 				struct srcpos *srcpos)
 {
 	struct property *new = xmalloc(sizeof(*new));
 
 	memset(new, 0, sizeof(*new));
 
-	new->name = xstrdup(name);
+	new->name = name;
 	new->val = val;
 	new->srcpos = srcpos_copy(srcpos);
 
 	return new;
 }
 
-struct property *build_property_delete(const char *name)
+struct property *build_property_delete(char *name)
 {
 	struct property *new = xmalloc(sizeof(*new));
 
 	memset(new, 0, sizeof(*new));
 
-	new->name = xstrdup(name);
+	new->name = name;
 	new->deleted = 1;
 
 	return new;
@@ -116,11 +116,11 @@ struct node *build_node_delete(struct srcpos *srcpos)
 	return new;
 }
 
-struct node *name_node(struct node *node, const char *name)
+struct node *name_node(struct node *node, char *name)
 {
 	assert(node->name == NULL);
 
-	node->name = xstrdup(name);
+	node->name = name;
 
 	return node;
 }
@@ -250,7 +250,6 @@ struct node * add_orphan_node(struct node *dt, struct node *new_node, char *ref)
 	name_node(new_node, "__overlay__");
 	node = build_node(p, new_node, NULL);
 	name_node(node, name);
-	free(name);
 
 	add_child(dt, node);
 	return dt;
@@ -439,9 +438,9 @@ cell_t propval_cell(struct property *prop)
 	return fdt32_to_cpu(*((fdt32_t *)prop->val.val));
 }
 
-cell_t propval_cell_n(struct property *prop, unsigned int n)
+cell_t propval_cell_n(struct property *prop, int n)
 {
-	assert(prop->val.len / sizeof(cell_t) > n);
+	assert(prop->val.len / sizeof(cell_t) >= n);
 	return fdt32_to_cpu(*((fdt32_t *)prop->val.val + n));
 }
 
@@ -527,7 +526,7 @@ struct node *get_node_by_path(struct node *tree, const char *path)
 	p = strchr(path, '/');
 
 	for_each_child(tree, child) {
-		if (p && strprefixeq(path, (size_t)(p - path), child->name))
+		if (p && strprefixeq(path, p - path, child->name))
 			return get_node_by_path(child, p+1);
 		else if (!p && streq(path, child->name))
 			return child;
@@ -560,7 +559,7 @@ struct node *get_node_by_phandle(struct node *tree, cell_t phandle)
 {
 	struct node *child, *node;
 
-	if (!phandle_is_valid(phandle)) {
+	if ((phandle == 0) || (phandle == -1)) {
 		assert(generate_fixups);
 		return NULL;
 	}
@@ -582,62 +581,20 @@ struct node *get_node_by_phandle(struct node *tree, cell_t phandle)
 
 struct node *get_node_by_ref(struct node *tree, const char *ref)
 {
-	struct node *target = tree;
-	const char *label = NULL, *path = NULL;
-
 	if (streq(ref, "/"))
 		return tree;
-
-	if (ref[0] == '/')
-		path = ref;
+	else if (ref[0] == '/')
+		return get_node_by_path(tree, ref);
 	else
-		label = ref;
-
-	if (label) {
-		const char *slash = strchr(label, '/');
-		char *buf = NULL;
-
-		if (slash) {
-			buf = xstrndup(label, slash - label);
-			label = buf;
-			path = slash + 1;
-		}
-
-		target = get_node_by_label(tree, label);
-
-		free(buf);
-
-		if (!target)
-			return NULL;
-	}
-
-	if (path)
-		target = get_node_by_path(target, path);
-
-	return target;
-}
-
-static void add_phandle_property(struct node *node,
-				 const char *name, int format)
-{
-	struct data d;
-
-	if (!(phandle_format & format))
-		return;
-	if (get_property(node, name))
-		return;
-
-	d = data_add_marker(empty_data, TYPE_UINT32, NULL);
-	d = data_append_cell(d, node->phandle);
-
-	add_property(node, build_property(name, d, NULL));
+		return get_node_by_label(tree, ref);
 }
 
 cell_t get_node_phandle(struct node *root, struct node *node)
 {
 	static cell_t phandle = 1; /* FIXME: ick, static local */
+	struct data d = empty_data;
 
-	if (phandle_is_valid(node->phandle))
+	if ((node->phandle != 0) && (node->phandle != -1))
 		return node->phandle;
 
 	while (get_node_by_phandle(root, phandle))
@@ -645,8 +602,16 @@ cell_t get_node_phandle(struct node *root, struct node *node)
 
 	node->phandle = phandle;
 
-	add_phandle_property(node, "linux,phandle", PHANDLE_LEGACY);
-	add_phandle_property(node, "phandle", PHANDLE_EPAPR);
+	d = data_add_marker(d, TYPE_UINT32, NULL);
+	d = data_append_cell(d, phandle);
+
+	if (!get_property(node, "linux,phandle")
+	    && (phandle_format & PHANDLE_LEGACY))
+		add_property(node, build_property("linux,phandle", d, NULL));
+
+	if (!get_property(node, "phandle")
+	    && (phandle_format & PHANDLE_EPAPR))
+		add_property(node, build_property("phandle", d, NULL));
 
 	/* If the node *does* have a phandle property, we must
 	 * be dealing with a self-referencing phandle, which will be
@@ -816,18 +781,18 @@ void sort_tree(struct dt_info *dti)
 }
 
 /* utility helper to avoid code duplication */
-static struct node *build_and_name_child_node(struct node *parent, const char *name)
+static struct node *build_and_name_child_node(struct node *parent, char *name)
 {
 	struct node *node;
 
 	node = build_node(NULL, NULL, NULL);
-	name_node(node, name);
+	name_node(node, xstrdup(name));
 	add_child(parent, node);
 
 	return node;
 }
 
-static struct node *build_root_node(struct node *dt, const char *name)
+static struct node *build_root_node(struct node *dt, char *name)
 {
 	struct node *an;
 
@@ -927,12 +892,6 @@ static void add_fixup_entry(struct dt_info *dti, struct node *fn,
 	/* m->ref can only be a REF_PHANDLE, but check anyway */
 	assert(m->type == REF_PHANDLE);
 
-	/* The format only permits fixups for references to label, not
-	 * references to path */
-	if (strchr(m->ref, '/'))
-		die("Can't generate fixup for reference to path &{%s}\n",
-		    m->ref);
-
 	/* there shouldn't be any ':' in the arguments */
 	if (strchr(node->fullpath, ':') || strchr(prop->name, ':'))
 		die("arguments should not contain ':'\n");
@@ -1048,7 +1007,7 @@ static void generate_local_fixups_tree_internal(struct dt_info *dti,
 		generate_local_fixups_tree_internal(dti, lfn, c);
 }
 
-void generate_label_tree(struct dt_info *dti, const char *name, bool allocph)
+void generate_label_tree(struct dt_info *dti, char *name, bool allocph)
 {
 	if (!any_label_tree(dti, dti->dt))
 		return;
@@ -1056,7 +1015,7 @@ void generate_label_tree(struct dt_info *dti, const char *name, bool allocph)
 				     dti->dt, allocph);
 }
 
-void generate_fixups_tree(struct dt_info *dti, const char *name)
+void generate_fixups_tree(struct dt_info *dti, char *name)
 {
 	if (!any_fixup_tree(dti, dti->dt))
 		return;
@@ -1064,7 +1023,7 @@ void generate_fixups_tree(struct dt_info *dti, const char *name)
 				      dti->dt);
 }
 
-void generate_local_fixups_tree(struct dt_info *dti, const char *name)
+void generate_local_fixups_tree(struct dt_info *dti, char *name)
 {
 	if (!any_local_fixup_tree(dti, dti->dt))
 		return;
diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index 8e4d18a90b47..f5205fb9c1ff 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -3,9 +3,7 @@
  * Copyright 2007 Jon Loeliger, Freescale Semiconductor, Inc.
  */
 
-#ifndef _GNU_SOURCE
 #define _GNU_SOURCE
-#endif
 
 #include <stdio.h>
 
@@ -22,7 +20,7 @@ struct search_path {
 static struct search_path *search_path_head, **search_path_tail;
 
 /* Detect infinite include recursion. */
-#define MAX_SRCFILE_DEPTH     (200)
+#define MAX_SRCFILE_DEPTH     (100)
 static int srcfile_depth; /* = 0 */
 
 static char *get_dirname(const char *path)
@@ -313,8 +311,8 @@ srcpos_string(struct srcpos *pos)
 static char *
 srcpos_string_comment(struct srcpos *pos, bool first_line, int level)
 {
-	char *pos_str, *fresh_fname = NULL, *first, *rest;
-	const char *fname;
+	char *pos_str, *fname, *first, *rest;
+	bool fresh_fname = false;
 
 	if (!pos) {
 		if (level > 1) {
@@ -332,9 +330,9 @@ srcpos_string_comment(struct srcpos *pos, bool first_line, int level)
 	else if (level > 1)
 		fname = pos->file->name;
 	else {
-		fresh_fname = shorten_to_initial_path(pos->file->name);
-		if (fresh_fname)
-			fname = fresh_fname;
+		fname = shorten_to_initial_path(pos->file->name);
+		if (fname)
+			fresh_fname = true;
 		else
 			fname = pos->file->name;
 	}
@@ -348,7 +346,7 @@ srcpos_string_comment(struct srcpos *pos, bool first_line, int level)
 			  first_line ? pos->first_line : pos->last_line);
 
 	if (fresh_fname)
-		free(fresh_fname);
+		free(fname);
 
 	if (pos->next != NULL) {
 		rest = srcpos_string_comment(pos->next, first_line, level);
diff --git a/scripts/dtc/treesource.c b/scripts/dtc/treesource.c
index ae15839ba6a5..061ba8c9c5e8 100644
--- a/scripts/dtc/treesource.c
+++ b/scripts/dtc/treesource.c
@@ -124,6 +124,27 @@ static void write_propval_int(FILE *f, const char *p, size_t len, size_t width)
 	}
 }
 
+static bool has_data_type_information(struct marker *m)
+{
+	return m->type >= TYPE_UINT8;
+}
+
+static struct marker *next_type_marker(struct marker *m)
+{
+	while (m && !has_data_type_information(m))
+		m = m->next;
+	return m;
+}
+
+size_t type_marker_length(struct marker *m)
+{
+	struct marker *next = next_type_marker(m->next);
+
+	if (next)
+		return next->offset - m->offset;
+	return 0;
+}
+
 static const char *delim_start[] = {
 	[TYPE_UINT8] = "[",
 	[TYPE_UINT16] = "/bits/ 16 <",
@@ -139,28 +160,6 @@ static const char *delim_end[] = {
 	[TYPE_STRING] = "",
 };
 
-static void add_string_markers(struct property *prop)
-{
-	int l, len = prop->val.len;
-	const char *p = prop->val.val;
-
-	for (l = strlen(p) + 1; l < len; l += strlen(p + l) + 1) {
-		struct marker *m, **nextp;
-
-		m = xmalloc(sizeof(*m));
-		m->offset = l;
-		m->type = TYPE_STRING;
-		m->ref = NULL;
-		m->next = NULL;
-
-		/* Find the end of the markerlist */
-		nextp = &prop->val.markers;
-		while (*nextp)
-			nextp = &((*nextp)->next);
-		*nextp = m;
-	}
-}
-
 static enum markertype guess_value_type(struct property *prop)
 {
 	int len = prop->val.len;
@@ -186,8 +185,6 @@ static enum markertype guess_value_type(struct property *prop)
 
 	if ((p[len-1] == '\0') && (nnotstring == 0) && (nnul <= (len-nnul))
 	    && (nnotstringlbl == 0)) {
-		if (nnul > 1)
-			add_string_markers(prop);
 		return TYPE_STRING;
 	} else if (((len % sizeof(cell_t)) == 0) && (nnotcelllbl == 0)) {
 		return TYPE_UINT32;
@@ -232,41 +229,26 @@ static void write_propval(FILE *f, struct property *prop)
 		size_t chunk_len = (m->next ? m->next->offset : len) - m->offset;
 		size_t data_len = type_marker_length(m) ? : len - m->offset;
 		const char *p = &prop->val.val[m->offset];
-		struct marker *m_phandle;
 
-		if (is_type_marker(m->type)) {
+		if (has_data_type_information(m)) {
 			emit_type = m->type;
 			fprintf(f, " %s", delim_start[emit_type]);
 		} else if (m->type == LABEL)
 			fprintf(f, " %s:", m->ref);
+		else if (m->offset)
+			fputc(' ', f);
 
-		if (emit_type == TYPE_NONE || chunk_len == 0)
+		if (emit_type == TYPE_NONE) {
+			assert(chunk_len == 0);
 			continue;
+		}
 
 		switch(emit_type) {
 		case TYPE_UINT16:
 			write_propval_int(f, p, chunk_len, 2);
 			break;
 		case TYPE_UINT32:
-			m_phandle = prop->val.markers;
-			for_each_marker_of_type(m_phandle, REF_PHANDLE)
-				if (m->offset == m_phandle->offset)
-					break;
-
-			if (m_phandle) {
-				if (m_phandle->ref[0] == '/')
-					fprintf(f, "&{%s}", m_phandle->ref);
-				else
-					fprintf(f, "&%s", m_phandle->ref);
-				if (chunk_len > 4) {
-					fputc(' ', f);
-					write_propval_int(f, p + 4, chunk_len - 4, 4);
-				}
-			} else {
-				write_propval_int(f, p, chunk_len, 4);
-			}
-			if (data_len > chunk_len)
-				fputc(' ', f);
+			write_propval_int(f, p, chunk_len, 4);
 			break;
 		case TYPE_UINT64:
 			write_propval_int(f, p, chunk_len, 8);
diff --git a/scripts/dtc/util.c b/scripts/dtc/util.c
index 507f0120cd13..40274fb79236 100644
--- a/scripts/dtc/util.c
+++ b/scripts/dtc/util.c
@@ -33,17 +33,6 @@ char *xstrdup(const char *s)
 	return d;
 }
 
-char *xstrndup(const char *s, size_t n)
-{
-	size_t len = strnlen(s, n) + 1;
-	char *d = xmalloc(len);
-
-	memcpy(d, s, len - 1);
-	d[len - 1] = '\0';
-
-	return d;
-}
-
 int xavsprintf_append(char **strp, const char *fmt, va_list ap)
 {
 	int n, size = 0;	/* start with 128 bytes */
@@ -364,11 +353,11 @@ int utilfdt_decode_type(const char *fmt, int *type, int *size)
 	}
 
 	/* we should now have a type */
-	if ((*fmt == '\0') || !strchr("iuxsr", *fmt))
+	if ((*fmt == '\0') || !strchr("iuxs", *fmt))
 		return -1;
 
 	/* convert qualifier (bhL) to byte size */
-	if (*fmt != 's' && *fmt != 'r')
+	if (*fmt != 's')
 		*size = qualifier == 'b' ? 1 :
 				qualifier == 'h' ? 2 :
 				qualifier == 'l' ? 4 : -1;
diff --git a/scripts/dtc/util.h b/scripts/dtc/util.h
index b448cd79efd3..a771b4654c76 100644
--- a/scripts/dtc/util.h
+++ b/scripts/dtc/util.h
@@ -13,12 +13,10 @@
  */
 
 #ifdef __GNUC__
-#ifdef __MINGW_PRINTF_FORMAT
-#define PRINTF(i, j)	__attribute__((format (__MINGW_PRINTF_FORMAT, i, j)))
-#elif __GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
-#define PRINTF(i, j)	__attribute__((format (gnu_printf, i, j)))
-#else
+#ifdef __clang__
 #define PRINTF(i, j)	__attribute__((format (printf, i, j)))
+#else
+#define PRINTF(i, j)	__attribute__((format (gnu_printf, i, j)))
 #endif
 #define NORETURN	__attribute__((noreturn))
 #else
@@ -63,11 +61,10 @@ static inline void *xrealloc(void *p, size_t len)
 }
 
 extern char *xstrdup(const char *s);
-extern char *xstrndup(const char *s, size_t len);
 
 extern int PRINTF(2, 3) xasprintf(char **strp, const char *fmt, ...);
 extern int PRINTF(2, 3) xasprintf_append(char **strp, const char *fmt, ...);
-extern int PRINTF(2, 0) xavsprintf_append(char **strp, const char *fmt, va_list ap);
+extern int xavsprintf_append(char **strp, const char *fmt, va_list ap);
 extern char *join_path(const char *path, const char *name);
 
 /**
@@ -146,7 +143,6 @@ int utilfdt_write_err(const char *filename, const void *blob);
  *		i	signed integer
  *		u	unsigned integer
  *		x	hex
- *		r	raw
  *
  * TODO: Implement ll modifier (8 bytes)
  * TODO: Implement o type (octal)
@@ -164,7 +160,7 @@ int utilfdt_decode_type(const char *fmt, int *type, int *size);
  */
 
 #define USAGE_TYPE_MSG \
-	"<type>\ts=string, i=int, u=unsigned, x=hex, r=raw\n" \
+	"<type>\ts=string, i=int, u=unsigned, x=hex\n" \
 	"\tOptional modifier prefix:\n" \
 	"\t\thh or b=byte, h=2 byte, l=4 byte (default)";
 
diff --git a/scripts/dtc/version_gen.h b/scripts/dtc/version_gen.h
index bf81ce593685..054cdd0fdbe8 100644
--- a/scripts/dtc/version_gen.h
+++ b/scripts/dtc/version_gen.h
@@ -1 +1 @@
-#define DTC_VERSION "DTC 1.7.0-gbcd02b52"
+#define DTC_VERSION "DTC 1.6.0-gcbca977e"
diff --git a/scripts/dtc/yamltree.c b/scripts/dtc/yamltree.c
index 55908c829c98..4e93c12dc658 100644
--- a/scripts/dtc/yamltree.c
+++ b/scripts/dtc/yamltree.c
@@ -29,12 +29,11 @@ char *yaml_error_name[] = {
 		    (emitter)->problem, __func__, __LINE__);		\
 })
 
-static void yaml_propval_int(yaml_emitter_t *emitter, struct marker *markers,
-	char *data, unsigned int seq_offset, unsigned int len, int width)
+static void yaml_propval_int(yaml_emitter_t *emitter, struct marker *markers, char *data, int len, int width)
 {
 	yaml_event_t event;
 	void *tag;
-	unsigned int off;
+	int off, start_offset = markers->offset;
 
 	switch(width) {
 		case 1: tag = "!u8"; break;
@@ -67,7 +66,7 @@ static void yaml_propval_int(yaml_emitter_t *emitter, struct marker *markers,
 			m = markers;
 			is_phandle = false;
 			for_each_marker_of_type(m, REF_PHANDLE) {
-				if (m->offset == (seq_offset + off)) {
+				if (m->offset == (start_offset + off)) {
 					is_phandle = true;
 					break;
 				}
@@ -113,9 +112,8 @@ static void yaml_propval_string(yaml_emitter_t *emitter, char *str, int len)
 static void yaml_propval(yaml_emitter_t *emitter, struct property *prop)
 {
 	yaml_event_t event;
-	unsigned int len = prop->val.len;
+	int len = prop->val.len;
 	struct marker *m = prop->val.markers;
-	struct marker *markers = prop->val.markers;
 
 	/* Emit the property name */
 	yaml_scalar_event_initialize(&event, NULL,
@@ -153,19 +151,19 @@ static void yaml_propval(yaml_emitter_t *emitter, struct property *prop)
 
 		switch(m->type) {
 		case TYPE_UINT16:
-			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 2);
+			yaml_propval_int(emitter, m, data, chunk_len, 2);
 			break;
 		case TYPE_UINT32:
-			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 4);
+			yaml_propval_int(emitter, m, data, chunk_len, 4);
 			break;
 		case TYPE_UINT64:
-			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 8);
+			yaml_propval_int(emitter, m, data, chunk_len, 8);
 			break;
 		case TYPE_STRING:
 			yaml_propval_string(emitter, data, chunk_len);
 			break;
 		default:
-			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 1);
+			yaml_propval_int(emitter, m, data, chunk_len, 1);
 			break;
 		}
 	}
